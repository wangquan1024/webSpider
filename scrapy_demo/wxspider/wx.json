{"title": "5个套路看懂微信小程序开发 ", "author": "Rolan", "pub_time": "2019-6-21 00:17", "content": [" \n                     \n                    ", "你或许听说过，快速入门就是要学最小必要知识。而我最近在看微信", "小程序", "的官方教程时发现，这个教程虽然简单，但对于微信小程序开发来说，80%的套路都能从这里学习到，你的小程序从0到1可以从这里实现突破。", "在开始之前，先做100字的铺垫。", "一个页面 = 4个文件", "小程序的每个页面都是由4个文件组成的 ，前两个最重要，是我们的重头戏。先给这几个文件一个简短的解释：", "js 文件——数据来源；", "wxml 文件——页面的骨架；", "wxss 文件——页面的装饰效果；", "json 文件——可选，配置页面上的零件。", "另外，本文的目标读者是真心想要尝试小程序的无经验开发者，英语水平要求中学及格水平以上。另外，为了你可以动手跟着做，请下载微信开发工具并注册微信小程序。", "部分语言过于通俗是为了更好的理解。", "绑定数据", "现在就开始我们的第一个套路。", "小程序简易教程 -> 编写代码 -> 创建页面 -> 第二个代码块", "依照小程序的定义，小程序中的每个页面都包含一个js文件。在一个 js 文件中，你需要列出这个页面上需要的数据（上图红框中的内容）。也就是说，data下面规定的数据（请努力去上图中找到 data），就是页面上需要用到的数据。这就叫做数据绑定。", "「数据绑定」对你来说可能是个新词汇。这里先不急着理解，我们的目标是会用，会用了就能理解一大半了。", "怎么应用「数据绑定」呢？只需要两步：1，声明；2，使用。", "声明的格式是这样的（类似上图中的内容）：", "Page({", "data: {", "greeting: 'Hello World'", "}", "//...", "})", "在微信开发工具中是这样的：", "注意看红框中的内容，和上面的代码块是一样的", "注意看 data 那个部分，我声明了名字为greeting的数据。（所谓数据，学名应该叫变量，但在我们的教程里可以近似理解。）", "第二步是使用。使用的意思是，我们到页面上把这个数据显示出来。方法是这样的：", "{{greeting}}", "注意看{{ }}之间的部分，我们只需要把刚刚定义好的数据名称写在两个大括号里就行了。顺带一提，这种使用数据的方法，叫做八字胡方法（英文Mustache），因为加上的两个大括号可以想象成嘴上的胡子。或许记住了胡子，你就记住了这种使用方法。", "这就完成了我们的第一个套路——数据绑定。简单吧！", "但是这里有一个疑问，我们在哪里使用绑定好的数据呢？也就是问，在哪里使用{{greeting}}这句程序呢？", "答案是我们的页面上，也就是 wxml 这个文件中。这就是我们的下一个套路——显示数据。", "显示数据", "上一个套路的讲解中，我们出现了这样一句程序{{greeting}}。这是在使用数据。但这行代码的完整版其实是这样的：", "<text class=\"your-class\">{{greeting}}</text>", "在微信开发工具中的样子是这样的：", "还是看红框内的内容，也请注意这是在 wxml 文件中", "我们对{{greeting}}这一部分已经熟悉，但对于它前面和后面的代码还不熟悉。所以我们现在进行讲解。", "显示数据时，我们其实希望显示出来的内容是很好看的。但如果你只写成{{greeting}}，显示出来的效果并不好：", "最左边红框中的文字一点装饰效果都没有", "为了让显示数据有更好看的效果，我们需要对{{greeting}}进行装饰。怎么装饰数据呢。我们要用2个东西：", "标签", "样式表", "什么是标签，我们从例子中来理解：{{greeting}}两边的<text class=\"your-class\">和</text>就是标签，而且分别叫开始标签和结束标签。（你能发现开始标签和结束标签的区别么？）", "开始标签可以定义一些属性，以便调整显示的结果。这就像是你画一幅画可以选择用毛笔，来画出国画的效果。在上面的例子中，class=\"your-class\"就是<text>这个标签的一个属性，<text>标签会表现出class=\"your-class\"的规定的样子。", "那么class=\"your-class\"这个属性的完整意思是什么呢？他的意思是<text>的 class 对应样式表中的your-class。对，你可以把等号理解为对应。而后面的\"your-class\"就是我们在样式表中规定好的一种装饰效果。", "这里出现了我们的第2个工具：样式表。", "样式表是写在 wxss 文件中的，我们来看看怎么写：", ".your-class {", "display: flex;", "flex-direction: column;", "align-items: center;", "color: blue;", "}", "在开发者工具中的样子是这样的：", "你通过理解代码中英文的字面意思就可以了解到，我把字的 color 定义为蓝色，把位置定义为 center。", "最重要的，是这个样式的名字，叫做.your-class，而<text>标签中的 class 属性，正好指向这个样式，所以<text>中的数据会变成中间位置的蓝色字。（在.your-class的最前面有一个点，那是对应<text>中 class 属性的特有标记，还有类似的标记[1]，可以在以后更多的实践中去理解)", "到这里，我们的前两个套路就已经简单的介绍完了。总结一下：", "绑定数据：在 js 文件中的 Page 模块下面定义 data 的名字，并用八字胡方法({{ }})来使用数据。", "显示数据：在 wxml 中给数据加上标签（比如 text 标签），并且给标签加上属性（比如 class 属性）。class 对应的样式在 wxss 文件中写好。", "不过，我们这里好像缺了什么。我好像没教大家怎么写最后一步的 wxss。微信文档说，wxss 和 css 大体上都是一样的[2]。大家可以去找找css的书，或者期待我后续的实践教程，带你一步一步写一个能上线的小程序。", "现在，如果你把这两个套路循环用起来，已经能解决很多问题了。想要多显示一个数据，就先在 js文件中绑定这个数据，然后去 wxml 文件中装饰数据。下面是绑定两个数据的示例代码：", "Page({", "data: {", "greeting: 'Hello World',", "farewell: 'Goodbye!'", "}", "//其他内容", "})", "而对应显示这两个数据的示例代码是这样的：", "<!--index.wxml-->", "<text class=\"your-class\">{{greeting}}</text>", "<view class=\"your-class\">{{farewell}}</view>", "在开发者工具中显示的样子是这样的：", "我在写教程的过程中升级了一次开发者工具，所以界面有变化", "大家可以看到，我在最右侧的红箭头处加入了一行新代码， 然后显示出了新数据。", "但是，这次不一样的是，我用了一个叫做<view>的标签，而不是之前的<text>标签。其实 wxml 文件中可以使用很多种标签来显示数据，有负责显示图片的，有可以负责滚动效果的的，他们都被写在微信文档中，你在实践的过程中可以查看。", "比如，我使用了一个叫做<icon>的标签，然后显示出了一个圆形的图标：", "有了「绑定数据」和「显示数据」这两个套路，我们已经能够写出一个简单的页面了。能够做到展示，但没有交互，所以我们进入第三个套路：绑定交互。", "绑定交互", "绑定交互这个名字听起来有没有和之前的「绑定数据」很像？他们的操作方法也很相似。", "绑定交互分为两步：", "声明：在 js 文件中声明交互的名称。", "使用：在 wxml 文件中使用这个交互。", "先来看「声明」。怎么声明一个交互呢？（或者用微信文档的说法，怎么来声明一个事件呢？）", "请在 js 文件中写下这样几行代码，就在我们之前绑定数据的 data 模块下面：", "changeWord: function() {", "this.setData({", "farewell: 'Never Say Goodbye!'", "})", "}", "在开发者工具中的样子是：", "这样，我们就声明了一个叫做changeWord的交互。这个交互的具体内容是，改变 farewell 这个数据的内容。原来是Goodbye!，现在我们要改成Never Say Goodbye!。", "而这个声明中function，this，setDate都是什么意思，我们在后面实践中再讲，大家关注的重点是这个声明中最前面的部分，也就是这个交互的名字：changeWord。", "我们已经声明完了这个交互，现在就该进入第2步——使用交互。请在 wxml 中插入这样的代码片段：", "<button bindtap=\"changeWord\" type='primary' class=\"your-button\" size='default'>改变文字</button>", "在开发者工具中的的样子是这样的：", "这里的重点是bindtap=\"changeWord\"，大家可以看到我们刚刚声明的交互changeWord出现了，那前面的bingtap=是什么呢？他的意思是：把点击事件的交互对应到changeWord。当你点一下图中的那个绿色按钮，我们的页面就会把Goodbye!换为 Never Say Goodbye!", "除了利用标签的bindtap属性来绑定交互，还可以用bindlongtap（绑定长按事件），bindtouchmove（绑定触摸后移动事件）等等，他们都有各自的效果。具体内容都被写在事件相关的文档中，你可以亲自试一下。", "你会发现他们的开头都是 bind，就好像单词的前缀一样，加上tap，longtap等后缀，就能帮你绑定一个交互。（绑定事件的前缀还有另外一种，叫catch，比如catchtap，catchtouchmove等等，你可以结合文档，试验一下他们的效果）[3]", "到这里，我们已经能够简单的绑定交互了。但绑定交互的核心目的是要改变页面上的显示，从而给用户一个反馈。下面就让我们来看看第4个套路：修改显示。", "执行交互", "就像绑定数据之后，要去显示数据。我们绑定交互之后，也要让交互被执行，这样才有意义。而交互的执行内容，就写在被声明的交互的下面：", "changeWord: function() {", "// 这里写交互的实际内容", "}", "我们这里介绍两种交互内容的写法，足够解决很多问题了：", "修改页面数据", "弹窗", "第一种，修改页面数据。我们在上一个套路的实例代码中已经见过：", "changeWord: function() {", "this.setData({", "farewell: 'Never Say Goodbye!'", "})", "}", "这几行代码中间的部分，就是要执行的交互内容：", "this.setData({", "farewell: 'Never Say Goodbye!'", "})", "即使你不懂得javaScript编程语言，也完全可以从英语的字面意思去理解这几行代码。这3行代码是在说，我这个页面(this)要修改数据(setData)中的farewell为 Never Say Goodbye!。", "如果你想修改其他数据，比如greeting，你可以如法炮制：", "changeAnotherWord: function() {", "this.setData({", "greeting: 'Hello, again!'", "})", "}", "你会发现这里面有很多结构是固定的。变化的部分只有交互的名称（变成了changeAnotherWord）和要修改的数据（变成了greeting: 'Hello, again!'）。如果你也想修改页面上的数据，请如法炮制。", "我们要介绍的第二种交互方法是弹窗，而且是微信内建的弹窗。首先，还是要做一下绑定交互这个套路：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。", "声明交互的代码如下（在 js 文件中），我们用showConfirmation作为名称：", " showConfirmation: ", "function", "()", " {", "\r\n var that = this\r\n wx.showModal({\r\n title: ", "'提示'", ",\r\n conten", "t:", " ", "'你确定要更改文字吗？'", ",\r\n showCance", "l:", " true,\r\n cancelTex", "t:", " ", "'取消'", ",\r\n confirmTex", "t:", " ", "'确定'", ",\r\n succes", "s:", " ", "function", " ", "(response)", " { ", "\r\n that.changeWord()\r\n }\r\n })\r\n }\r\n", "在微信开发者工具中是这样的：", "先不要在乎这里面陌生的代码，我们继续看使用交互的部分：", "<button bindtap=\"showConfirmation\" type='primary' class=\"your-button\" size='default'>改变文字</button>", "我把上一个套路中出现的 button 改写成了绑定到这个showConfirmation，在微信开发者工具中的样子是这样的：", "写完之后，我再去点「改变文字」的按钮，就会出现对话框：", "箭头连接的两部分是一样的，你发现了吗", "你会发现，所有的不一样，都只是在 js 文件中showConfirmation的下面，其他的部分都符合我们以前的套路。那我们就看看那段陌生的代码：", " var that = this\r\n wx.showModal({\r\n title: ", "'提示'", ",\r\n conten", "t:", " ", "'你确定要更改文字吗？'", ",\r\n showCance", "l:", " true,\r\n cancelTex", "t:", " ", "'取消'", ",\r\n confirmTex", "t:", " ", "'确定'", ",\r\n succes", "s:", " ", "function", " ", "(response)", " { ", "\r\n that.changeWord()\r\n }\r\n })\r\n", "我们从wx.showModal看起，这是一个微信内建的代码表达方式，从英文的字面就能理解他是什么意思：请微信（wx）显示一下对话框（showModal）。那怎么用这个工具呢，微信的文档里面已经写好了：", "我们只需要像填空一样，把制作对话框需要的 title, content, showCancel 等需要填充的地方填好就可以了。这样，微信会帮助我们制作出一个对话框。", "但在这段代码中，有一个比较难解释的地方，就是var that = this和that.changeWord()。你能猜到他们是联动的，因为他们都有一个that。具体的意思是：把这个页面存储在那个地方（var that = this），让那个地方的数据中的文字改变（that.changeWord()）。为了避免混乱，我们暂时解释到这里。而且这两行也不影响我们制作一个对话框。因为制作对话框只需要做一件事[4]：", "使用wx.showModal", "跳转", "到这里，我们已经能在一个页面上使用4个套路了：绑定数据，显示数据，绑定交互，修改数据。如果你的小程序比较复杂，那么，是时候跳转到下一个页面来开辟一片新战场。", "要跳转到下一个页面，我们只需要最后一个套路：跳转。", "跳转本质上也是一种交互，我们完全可以用上面提到的「绑定交互」和「执行交互」来实现。再重复一遍这两步：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。", "我们先在 js 文件中声明一个名为navigateToLogs的交互：", "navigateToLogs: function() {", "wx.navigateTo({", "url: '/pages/logs/logs'", "})", "}", "在开发者工具中的样子是这样的：", "这里面有我们不太熟悉的代码，比如wx.navigateTo，根据上一个套路的经验，你已经能够大致猜到他的意思了，对么？不过我们还是把下一步走完再说。", "在 wxml 中使用这个交互：", "<button bindtap=\"navigateToLogs\" type='default' class=\"your-button\" size='default'>跳转</button>", "在开发者工具中的样子是这样的：", "好了，现在，如果我们点一下「跳转」按钮，他就会跳到下一页。", "已经看完了效果，我们回来看那段不熟悉的代码：", "wx.navigateTo({", "url: '/pages/logs/logs'", "})", "这一次，我们依然可以从字面理解：请微信（wx）导航到（navigateTo）logs 路径下的页面（url: '/pages/logs/logs'）。其中 url 这个数据是微信要求的，在文档中可以找到他的说明，我们依然是照着文档来填空就可以了[5]。", "这里面有一点需要说明，新页面的地址叫做'/pages/logs/logs'，他是从哪里来的呢？", "大家看下图红框中的文件结构，会发现 logs 这个页面的地址就是 pages 文件夹下面的 logs 文件夹下面的 logs 文件（有4个文件，但都叫 logs），用标准的格式表示，就成了我们刚刚提到的/pages/logs/logs。更进一步，按照微信的规定，我们还需要把他写在一个叫做app.json的配置文件中，这样微信才允许我们跳转到那个路径。", "总结一下", "好了，到这里，我们把5个套路都学完了。如果你能把他们组合起来，不断使用，你就能制作一个用很多功能的小程序：", "绑定数据——在 js 文件中声明数据名称", "显示数据——在 wxml 中写出数据显示的位置，并在 wxss 中写出装饰效果", "绑定交互——在 js 文件中声明交互的名称", "执行交互——在 js 文件中支出要修改的数据或者显示弹窗", "跳转——跳转到下一页，开辟新的战场", "番外篇——调取微信数据", "微信小程序其实还有一个隐含套路，叫做调用微信提供的接口。用微信官方的话讲，就是使用微信的能力。如果没有这些能力，微信小程序只能叫小程序，而不能叫「微信」小程序。", "其实，我们已经在上面见过一些微信小程序的能力了，比如显示弹窗的wx.showModal，比如跳转下一页的wx.navigateTo", "你已经发现，他们的特点都是wx.开头。更多的能力还有，还有获取用户头像，打开扫一扫这样的能力。他们怎么用呢？其实都是查文档，看看这个方法需要你提供哪些数据，提供给他就好了。用两个字总结就是：填空。", "最后的最后，轻轻说一句，对于刚刚入门的开发者，最大的坑可能是——忘记保存。因为我曾经也是个新手，在很多领域依然是新手，甚至还没有入门。希望这份教程能帮到你。", "共勉。", "这种标记叫做选择器，可以在这个小程序 wxss 文档的选择器那一节找到", "而且是个简版的css，不会用到复杂一点的级联样式", "另外，还有两类特殊的交互，为了避免大家混乱，我没有讲，但在我们后续的教程中会用到，感兴趣的朋友可以先了解一下：一类是某些标签特有的绑定方法，比如<checkbox-group>便签有一个特有属性 bindchange，可以用来绑定交互。另一类是用户关闭和打开页面时绑定的交互，比如onLoad，这类交互都是以 on 开头的，代表这个页面的事件，直接在 js 文件中声明，不用再 wxml 中绑定到标签。", "微信还有2个可用弹窗类交互，大家可以对照文档进行实验。", "微信出了提供wx.navigateTo这个跳转方法，还提供了其他4个导航相关的方法，你可以在实践中体会他们的区别。另外，微信还提供了<navigator>标签来实现跳转，跟wx.navigateTo等方法实现同样效果，为避免混乱，这里只留下文档地址，不详细举例。", " "]}
{"title": "微信小程序渲染性能调优 ", "author": "Rolan", "pub_time": "2019-7-30 00:12", "content": [" \n                     \n                    ", "网页的性能优化是前端开发老生常谈的热门话题，其中微信", "小程序", "因其页面双线程架构设计，所以性能优化的手段跟传统的 ", "H5", " 应用不太一样。今天主要介绍一下微信小程序页面双线程架构的特性给页面渲染带来的一些影响，以及应对的一些渲染性能调优策略。为了叙述方便，下文会把微信小程序简称为小程序。", "小程序的双线程架构", "与传统的浏览器Web页面最大区别在于，小程序的是基于 ", "双线程", " 模型的，在这种架构中，小程序的渲染层使用 ", "WebView", " 作为渲染载体，而逻辑层则由独立的 ", "JsCore", " 线程运行 ", "JS", " 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 ", "Native", " 的 ", "JSBrigde", " 做中转。", "小程序更新视图数据的通信流程", "每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 ", "setData", " 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。完整的通信流程如下：", "小程序逻辑层调用宿主环境的 ", "setData", " 方法。", "逻辑层执行 ", "JSON.stringify", " 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过 ", "evaluateJavascript", " 执行脚本将数据传输到渲染层。", "渲染层接收到后， ", "WebView JS", " 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 ", "WebView", " 线程空闲时进行页面渲染。", "WebView", " 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 ", "data", " 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 ", "diff", " 对比，将差异部分更新到UI视图。同时，将新的节点树替换旧节点树，用于下一次重渲染。", "引发渲染性能问题的一些原因", "在上述通信流程中，一些不恰当的操作可能会影响到页面渲染的性能：", "setData传递大量的新数据", "数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 ", "WebView JS", " 线程。", "下图是我们做的一组测试统计：在相同网络环境下，各个机型分别对大小为 ", "1KB", " 、 ", "2KB", " 、 ", "3KB", " 的数据执行 ", "setData", " 操作所消耗的时间。", "从图中可以看出， ", "setData", " 数据传输量越大，数据传输所消耗的时间越大。", "频繁的执行setData操作", "频繁的执行 ", "setData", " 会让 ", "WebView JS", " 线程一直忙碌于脚本的编译、节点树的对比计算和页面渲染。导致的结果是：", "WebView", " JS\r\n", "过多的页面节点数", "页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。", "每次执行 ", "setData", " 更新视图， ", "WebView JS", " 线程都要遍历节点树计算新旧节点数差异部分。当页面节点数量越多，计算的时间开销越大，减少节点树节点数量可以有效降低重渲染的时间开销。", "渲染性能优化", "基于引发渲染性能问题的原因，我们可以制定一些优化策略来避免性能问题的发生。", "setData优化", "setData", " 作为逻辑层与视图层通信的媒介，是最容易造成渲染性能瓶颈的 ", "API", " 。我们在使用 ", "setData", " 时应该遵循一些规则来尽可能避免性能问题的发生：", "减少 ", "setData", " 数据传输量", "仅传输视图层使用到的数据，其他 ", "JS", " 环境用到的数据存放到 ", "data", " 对象外。", "合理利用局部更新。 ", "setData", " 是支持使用 ", "数据路径", " 的方式对对象的局部字段进行更新，我们可能会遇到这样的场景： ", "list", " 列表是从后台获取的数据，并展示在页面上，当 ", "list", " 列表的第一项数据的 ", "src", " 字段需要更新时，一般情况下我们会从后台获取新的 ", "list", " 列表，执行 ", "setData", " 更新整个 ", "list", " 列表。", "// 后台获取列表数据", "\r\n  ", "const", " ", "list", " = requestSync(); \r\n\r\n  ", "// 更新整个列表", "\r\n  ", "this", ".setData({ ", "list", " });  \r\n复制代码", "实际上，只有个别字段需要更新时，我们可以这么写来避免整个 ", "list", " 列表更新:", "// 后台获取列表数据", "\r\n  ", "const", " ", "list", " = requestSync(); \r\n\r\n  ", "// 局部更新列表", "\r\n  this.setData({ \r\n      '", "list", "[", "0", "].src': ", "list", "[", "0", "].src\r\n  });  \r\n复制代码", "降低 ", "setData", " 执行频率", "在不影响业务流程的前提下，将多个 ", "setData", " 调用合并执行，减少线程间通信频次。", "当需要在频繁触发的用户事件（如 ", "PageScroll", " 、 ", "Resize", " 事件）中调用 ", "setData", " ，合理的利用 ", "函数防抖（debounce）", " 和 ", "函数节流（throttle）", " 可以减少 ", "setData", " 执行次数。", "函数防抖（debounce）", " ：函数在触发n秒后才执行一次，如果在n秒内重复触发函数，则重新计算时间。", "函数节流（throttle）", " ：单位时间内，只会触发一次函数，如果同一个单位时间内触发多次函数，只会有一次生效。", "除了让开发者自觉遵循规则来减少 ", "setData", " 数据传输量和执行频率之外，我们还可以自己设计一个 ", "diff", " 算法，重新对 ", "setData", " 进行封装，使得在 ", "setData", " 执行之前，让待更新的数据与原 ", "data", " 数据做 ", "diff", " 对比，计算出数据差异 ", "patch", " 对象，判断 ", "patch", " 对象是否为空，如果为空则跳过执行更新，否则再将 ", "patch", " 对象执行 ", "setData", " 操作，从而达到减少数据传输量和降低执行 ", "setData", " 频率的目的。", "//", " setData重新封装成新的方法，使得数据更新前先对新旧数据做diff对比，再执行setData方法\r\n", "this", ".update = ", "(data)", " =>", " {\r\n    ", "return", " ", "new", " Promise(", "(resolve, reject)", " =>", " {\r\n        const result = diff(data, ", "this", ".data);\r\n        ", "if", " (!Object.keys(result).length) {\r\n            resolve(", "null", ");\r\n            ", "return", ";\r\n        } \r\n        ", "this", ".setData(result, ", "()", " =>", " {\r\n            resolve(result);\r\n        });\r\n    });\r\n}\r\n复制代码", "当然，可以直接引用 ", "这里", " 的现成 ", "高性能小程序 ", "setData", " diff算法", "具体流程如下图：", "善用自定义组件", "小程序自定义组件的实现是由小程序官方设计的 ", "Exparser", " 框架所支持，框架实现的自定义组件的组件模型与 ", "Web Components", " 标准的 ", "Shadow DOM", " 相似：", "在页面引用自定义组件后，当初始化页面时， ", "Exparser", " 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 ", "data", " 数据和组件WXML，构造出独立的 ", "Shadow Tree", " ，并追加到页面 ", "Composed Tree", " 。创建出来的 ", "Shadow Tree", " 拥有着自己独立的逻辑空间、数据、样式环境及setData调用：", "基于自定义组件的 ", "Shadow DOM", " 模型设计，我们可以将页面中一些需要高频执行 ", "setData", " 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。当这些自定义组件视图需要更新时，执行的是组件自己的 ", "setData", " ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。", "下图是我们在微保小程序WeDrive首页中，将倒计时模块抽取自定义组件前后的setData更新耗时对比：", "从图中可以看出，使用自定义组件后，倒计时模块 ", "setData", " 平均渲染耗时有了非常明显的下降，实际在低端安卓机中体验会感觉明显的更流畅。", "当然，并不是使用自定义组件越多会越好，页面每新增一个自定义组件， ", "Exparser", " 需要多管理一个组件实例，内存消耗会更大，当内存占用上升到一定程度，有可能导致 ", "iOS", " 将部分 ", "WKWebView", " 回收，安卓机体验会变得更加卡顿。因此要合理的使用自定义组件，同时页面设计也要注意不滥用标签。", " "]}
{"title": "Taro+dva+Typescript 搭建微信小程序架构 ", "author": "Rolan", "pub_time": "2019-7-30 00:15", "content": [" \n                     \n                    ", "原文链接", "个人博客-欢迎访问", "效果预览图：", "微信", "小程序", "的开发目前是很热的一个领域，有很多的开发模式，找到一种属于自己的方法才会使得开发顺心顺利。", "此架构是使用 Taro + dva + typescript 构建前端开发", "京东凹凸实验室的React框架Taro很成熟，又是大厂在维护更新迭代，不用担心没人维护的问题，他有自己的UI还有物料社区，比起原生小程序方便很多，支持多端，一处代码，多处运行，微信小程序、H5、百度小程序、支付宝小程序、字节跳动小程序、QQ轻应用、快应用、ReactNative；", "数据管理是Redux集成的dva框架，是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架；", "TypeScript就是所谓的JavaScript超集。它不是JavaScript的替代品，也不会为JavaScript代码添加任何新功能。相反，TypeScript允许程序员在其代码中使用面向对象的构造，然后将其转换为JavaScript。它还包括类型安全和编译时类型检查等便利功能。", "资料", "Taro官网地址：https://taro.aotu.io/", "dva官网地址：https://dvajs.com/guide/", "开始", "前期工作准备", "cli 工具安装:", "# 使用 npm 安装 cli", "\r\n$ npm install -g @tarojs/cli\r\n\r\n", "# OR 使用 yarn 安装 cli", "\r\n$ yarn global add @tarojs/cli\r\n\r\n", "# OR 安装了 cnpm，使用 cnpm 安装 cli", "\r\n$ cnpm install -g @tarojs/cli\r\n\r\n\r\n复制代码", "使用命令创建模板项目:", "$ taro init Taro_dva_Typescript\r\n\r\n复制代码", "安装配置文件", "安装dva", "cnpm install --save dva-core dva-loading", "dva-core\r\ndva-loading\r\n", "安装@tarojs/redux", "cnpm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger", "配置项目文件", "去除不需要的文件，添加实际需要的一些文件，先删除 ", "./ssrc/page", " 下的index文件夹，后期使用命令行生成完整结构的文件夹。", "在``/src`目录下根据自己的实际需求进行一下配置：", "assets", "\r\nconfig\r\ncomponents\r\ntypes\r\nmodels\r\nutils\r\n", "项目一些具体配置操作", "1、在 ", "./src/config", " 下创建index.ts，添加项目配置信息", "/** \r\n * 这里为了方便测试使用 Easy Mock 模拟接口数据\r\n * \r\n * https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist\r\n*/", "\r\n\r\n", "export", " ", "const", " ONLINEHOST = ", "'https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist'", ";\r\n\r\n", "/** \r\n * mock 接口\r\n ", "* *", "/", " \r\n", "export", " ", "const", " MOCKHOST = ", "'https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist'", ";\r\n\r\n", "/** \r\n * 是否mock\r\n*/", "\r\n\r\n", "export", " ", "const", " ISMOCK = ", "true", ";\r\n\r\n\r\n", "/**\r\n * 这是一个全局的分享信息 不用每一个都去写\r\n */", "\r\n", "export", " ", "const", " SHAREINFO = {\r\n    ", "'title'", ": ", "'分享标题'", ",\r\n    ", "'path'", ": ", "'路径'", ",\r\n    ", "'imageUrl'", ": ", "'图片'", "\r\n  }\r\n\r\n\r\n复制代码", "2、在 ", "./src/utils", " 下创建dva.ts，配置dva", "import", " { create } ", "from", " ", "\"dva-core\"", ";\r\n", "import", " { createLogger } ", "from", " ", "\"redux-logger\"", ";\r\n", "import", "  createLoading  ", "from", " ", "\"dva-loading\"", ";\r\n\r\n\r\n\r\n", "let", " app\r\n", "let", " store\r\n", "let", " dispatch\r\n", "let", " registered\r\n\r\n", "function", " ", "createApp", "(", "opt", ") ", "{\r\n    ", "// redux 的日志", "\r\n    opt.onAction = [createLogger()]\r\n    app = create(opt)\r\n    app.use(createLoading({}))\r\n\r\n    ", "if", " (!registered) {\r\n        opt.models.forEach(", "model", " =>", " app.model(model));\r\n    }\r\n    registered = ", "true", ";\r\n    app.start()\r\n\r\n    store = app._store;\r\n    app.getStore = ", "()", " =>", " store;\r\n    app.use({\r\n        onError(err){\r\n            ", "console", ".log(err);\r\n        }\r\n    })\r\n\r\n    dispatch = store.dispatch;\r\n    app.dispatch = dispatch;\r\n    ", "return", " app;\r\n}\r\n\r\n", "export", " ", "default", "{\r\n    createApp,\r\n    getDispatch(){\r\n        ", "return", " app.dispatch\r\n    }\r\n}\r\n\r\n复制代码", "3、在 ", "./src/utils", " 下创建tips.ts，整合封装微信原生弹窗", "import", " Taro ", "from", " ", "\"@tarojs/taro\"", ";\r\n", "import", " { node } ", "from", " ", "\"_@types_prop-types@15.7.1@@types/prop-types\"", ";\r\n\r\n", "/** \r\n * 整合封装微信的原生弹窗\r\n * 提示、加载、工具类\r\n*/", "\r\n\r\n", "export", " ", "default", " ", "class", " ", "Tips", " ", "{\r\n\t", "static", " isLoading = ", "false", ";\r\n\r\n\t", "/** \r\n\t * 提示信息\r\n\t*/", "\r\n\t", "static", " toast(title: string, onHide?: ", "()", " =>", " ", "void", ") {\r\n\t\tTaro.showToast({\r\n\t\t\t", "title", ": title,\r\n\t\t\t", "icon", ": ", "'node'", ",\r\n\t\t\t", "mask", ": ", "true", ",\r\n\t\t\t", "duration", ": ", "1500", "\r\n\t\t});\r\n\t\t", "// 去除结束回调函数", "\r\n\t\t", "if", " (onHide) {\r\n\t\t\tsetTimeout(", "()", " =>", " {\r\n\t\t\t\tonHide();\r\n\t\t\t}, ", "500", ");\r\n\t\t}\r\n\t}\r\n\r\n\t", "/** \r\n\t * 加载提示弹窗\r\n\t*/", "\r\n\r\n\t", "static", " loding(title:", "'加载中'", ",force = ", "false", "){\r\n\t\t", "if", " (", "this", ".isLoading && !force) {\r\n\t\t\t", "return", "\r\n\t\t}\r\n\r\n\t\t", "this", ".isLoading = ", "true", ";\r\n\t\t", "if", " (Taro.showLoading) {\r\n\t\t\tTaro.showLoading({\r\n\t\t\t\t", "title", ":title,\r\n\t\t\t\t", "mask", ":", "true", "\r\n\t\t\t})\r\n\t\t}", "else", "{\r\n\t\t\tTaro.showNavigationBarLoading() ", "//导航条加载动画", "\r\n\t\t}\r\n\t}\r\n\r\n\t", "/** \r\n\t * 加载完成\r\n\t*/", "\r\n\t", "static", " loaded(){\r\n\t\t", "let", " duration = ", "0", ";\r\n\t\t", "if", " (", "this", ".isLoading) {\r\n\t\t\t", "this", ".isLoading = ", "false", ";\r\n\t\t\t", "if", " (Taro.hideLoading) {\r\n\t\t\t\tTaro.hideLoading()\r\n\t\t\t} ", "else", " {\r\n\t\t\t\tTaro.hideNavigationBarLoading(); ", "//导航条加载动画", "\r\n\t\t\t}\r\n\t\t\tduration = ", "500", ";\r\n\t\t}\r\n\t\t", "// 设定隐藏的动画时长为500ms,防止直接toast时出现问题", "\r\n\t\t", "return", " ", "new", " ", "Promise", "(", "resolve", " =>", " setTimeout(resolve,duration))\r\n\t}\r\n\r\n\t", "/** \r\n\t * 弹出提示框\r\n\t*/", "\r\n\r\n\t", "static", " success(title,duration = ", "1500", "){\r\n\t\tTaro.showToast({\r\n\t\t\t", "title", ": title,\r\n\t\t\t", "icon", ": ", "'success'", ",\r\n\t\t\t", "duration", ": duration,\r\n\t\t\t", "mask", ":", "true", "\r\n\t\t})\r\n\t\t", "if", " (duration > ", "0", ") {\r\n\t\t\t", "return", " ", "new", " ", "Promise", "(", "resolve", " =>", " setTimeout(resolve,duration))\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n复制代码", "4、在 ", "./src/config", " 下创建requestConfig.ts，统一配置请求接口", "/** \r\n * 请求公共参数\r\n*/", "\r\n\r\n", "export", " ", "const", " commonParame = {}\r\n\r\n", "/** \r\n * 请求的映射文件\r\n*/", "\r\n\r\n", "export", " ", "const", " requestConfig = {\r\n    loginUrl:", "'/api/user/wechat-auth'", " ", "// 微信的登陆接口", "\r\n}\r\n\r\n\r\n复制代码", "5、在 ", "./src/utils", " 下创建common.ts，共用函数", "/** \r\n * 共用函数\r\n*/", "\r\n\r\n", "export", " ", "const", " repeat = ", "(", "str = ", "'0'", ", times", ") =>", " (", "new", " ", "Array", "(times + ", "1", ")).join(str);\r\n", "// 时间前面 +0 ", "\r\n", "export", " ", "const", " pad = ", "(", "num, maxLength = ", "2", ") =>", " repeat(", "'0'", ", maxLength - num.toString().length) + num;\r\n\r\n", "// 全局的公共变量", "\r\n", "export", " ", "let", " globalData: any = {\r\n\r\n}\r\n\r\n", "// 时间格式装换函数", "\r\n\r\n", "export", " ", "const", " formatTime = ", "time", " =>", " {\r\n    ", "`", "${pad(time.getHours())}", ":", "${pad(time.getMinutes())}", ":", "${pad(time.getSeconds())}", ".", "${pad(time.getMilliseconds(), ", "3", ")}", "`", "\r\n}\r\n\r\n复制代码", "6、在 ", "./src/utils", " 下创建logger.ts，封装log函数", "/** \r\n * 封装logo函数\r\n*/", "\r\n\r\n", "import", " { formatTime } ", "from", " ", "'./common'", ";\r\n\r\n", "const", " defaults = {\r\n\t", "level", ": ", "'log'", ",\r\n\t", "logger", ": ", "console", ",\r\n\t", "logErrors", ": ", "true", ",\r\n\t", "colors", ": {\r\n\t\t", "title", ":", "'logger'", ",\r\n\t\t", "req", ":", "'#9e9e9e'", ",\r\n\t\t", "res", ":", "'#4caf50'", ",\r\n\t\t", "error", ":", "'#f20404'", ",\r\n\t}\r\n}\r\n\r\n", "function", " ", "printBuffer", "(", "logEntry, options", ")", "{\r\n\t", "const", " {logger,colors} = options;\r\n\t", "let", " {title,started,req,res} = logEntry;\r\n\t\r\n\t", "// Message", "\r\n\t", "const", " headerCSS = [", "'color:gray; font-weight:lighter;'", "]\r\n\t", "const", " styles = ", "s", " =>", " ", "`color ", "${s}", "; font-weight: bold`", ";\r\n\r\n\t", "// render", "\r\n\tlogger.group(", "`%c ", "${title}", " @", "${formatTime(started)}", "`", ", ...headerCSS);\r\n\tlogger.log(", "'%c req'", ", styles(colors.req), req)\r\n\tlogger.log(", "'%c res'", ", styles(colors.res), res)\r\n\tlogger.groupEnd()\r\n\r\n}\r\n\r\ninterface LogEntry{\r\n\tstarted ? : object  ", "// 触发时间", "\r\n}\r\n\r\n", "function", " ", "createLogger", "(", "options: LogEntry = {}", ")", "{\r\n\t", "const", " loggerOptions = ", "Object", ".assign({}, defaults, options)\r\n\t", "const", " logEntry = options\r\n\tlogEntry.started = ", "new", " ", "Date", "();\r\n\tprintBuffer(logEntry, ", "Object", ".assign({}, loggerOptions))\r\n}\r\n\r\n", "export", " {\r\n\tdefaults,\r\n\tcreateLogger,\r\n}\r\n\r\n复制代码", "7、在 ", "./src/utils", " 下创建request.ts，封装http请求", "import", " Taro,{ Component } ", "from", " ", "\"@tarojs/taro\"", ";\r\n", "import", " { ISMOCK,MAINHOST } ", "from", " ", "\"../config\"", ";\r\n", "import", " { commonParame,requestConfig } ", "from", " ", "\"../config/requestConfig\"", ";\r\n", "import", " Tips ", "from", " ", "\"./tips\"", ";\r\n\r\n\r\n", "// 封装请求", "\r\n\r\n\r\ndeclare type Methohs = ", "\"GET\"", " | ", "\"OPTIONS\"", " | ", "\"HEAD\"", " | ", "\"PUT\"", " | ", "\"DELETE\"", " | ", "\"TRACE\"", " | ", "\"CONNECT\"", ";\r\ndeclare type Headers = { [key :string]:string};\r\ndeclare type Datas = {", "method", " : Methohs; [key: string] : any;};\r\ninterface Options{\r\n    ", "url", ": string;\r\n    host?: string;\r\n    method?: Methohs;\r\n    data?: Datas;\r\n    header?: Headers;\r\n}\r\n\r\n", "export", " ", "class", " ", "Request", " ", "{\r\n    ", "// 登陆时的promise", "\r\n    ", "static", " loginReadyPromise: ", "Promise", "<any> = ", "Promise", ".resolve()\r\n\r\n    ", "// 正在登陆", "\r\n    ", "static", " isLoading: boolean = ", "false", "\r\n\r\n    ", "// 导出的API对象", "\r\n    ", "static", " apiLists: { [key: string]: ", "()", " =>", " any;} = {}\r\n\r\n    ", "// token", "\r\n    ", "static", " token: string = ", "''", "\r\n\r\n    ", "// 开始处理options", "\r\n    ", "static", " conbineOptions(opts, ", "data", ": Datas, ", "method", ": Methohs): Options {\r\n        ", "typeof", " opts ===  ", "'string'", " && (opts = {", "url", ": opts})\r\n        ", "return", " {\r\n            ", "data", ": { ...commonParame, ...opts.data, ...data },\r\n            ", "method", ": opts.method || data.method || method || ", "'GET'", ",\r\n            ", "url", ": ", "`", "${opts.host || MAINHOST}", "${opts.url}", "`", "\r\n        }\r\n    }\r\n\r\n    ", "static", " getToken(){\r\n        !", "this", ".token && (", "this", ".token = Taro.getStorageSync(", "'token'", "))\r\n        ", "return", " ", "this", ".token\r\n    }\r\n\r\n\r\n    ", "// 登陆", "\r\n    ", "static", " login(){\r\n        ", "if", " (!", "this", ".isLoading) {\r\n            ", "this", ".loginReadyPromise = ", "this", ".onLogining()\r\n        }\r\n        ", "return", " ", "this", ".loginReadyPromise\r\n    }\r\n\r\n    ", "static", " onLogining(){\r\n        ", "this", ".isLoading = ", "true", ";\r\n        ", "return", " ", "new", " ", "Promise", "(", "async", " (resolve, reject) => {\r\n            ", "// 获取code", "\r\n            ", "const", " { code } = ", "await", " Taro.login();\r\n\r\n            ", "const", " { data } = ", "await", " Taro.request({\r\n                ", "url", ": ", "`", "${MAINHOST}", "${requestConfig.loginUrl}", "`", ",\r\n                ", "data", ":{", "code", ": code}\r\n            })\r\n\r\n            ", "if", " (data.code !== ", "0", " || !data.data || !data.data.token) {\r\n                reject()\r\n                ", "return", "\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    ", "/** \r\n     * 基于 Taro.request 的 request 请求\r\n     * \r\n     * */", " \r\n    ", "static", " ", "async", " request(opts: Options) {\r\n        \r\n        ", "// Taro.request 请求", "\r\n        ", "const", " res = ", "await", " Taro.request(opts);\r\n\r\n        ", "// 是否mock", "\r\n        ", "if", "(ISMOCK) ", "return", " res.data;\r\n\r\n        ", "// 请求失败", "\r\n        ", "if", " (res.data.code === ", "99999", ") {\r\n            ", "await", " ", "this", ".login();\r\n            ", "return", " ", "this", ".request(opts)\r\n        }\r\n\r\n        ", "// 请求成功", "\r\n        ", "if", " (res.data) {\r\n            ", "return", " res.data\r\n        }\r\n\r\n        ", "// 请求错误", "\r\n        ", "const", " edata = { ...res.data, ", "err", " : (res.data && res.data.msg) || ", "'网络错误 ~'", "}\r\n        Tips.toast(edata.err)\r\n        ", "throw", " ", "new", " ", "Error", "(edata.err)\r\n\r\n    }\r\n\r\n\r\n    ", "/** \r\n     * 创建请求函数\r\n    */", "\r\n   ", "static", " creatRequests(opts: Options | string) : ", "()", " =>", " {} {\r\n       ", "console", ".log(", "'opts==>'", ",opts);\r\n       ", "return", " ", "async", " (data={}, ", "method", ": Methods = ", "\"GET\"", ") => {\r\n           ", "const", " _opts = ", "this", ".conbineOptions(opts, data, method)\r\n           ", "const", " res = ", "await", " ", "this", ".request(_opts)\r\n            ", "return", " res;\r\n        }\r\n   }\r\n\r\n   ", "/** \r\n    * 抛出API方法\r\n   */", "\r\n\r\n   ", "static", " getApiList(requestConfig){\r\n        ", "if", " (!", "Object", ".keys(requestConfig).length) {\r\n            ", "return", " {}\r\n        }\r\n        ", "Object", ".keys(requestConfig).forEach(", "(", "key", ")=>", "{\r\n            ", "this", ".apiLists[key] = ", "this", ".creatRequests(requestConfig[key])\r\n        })\r\n        ", "return", " ", "this", ".apiLists\r\n   }\r\n\r\n\r\n}\r\n\r\n", "const", " Api = Request.getApiList(requestConfig)\r\nComponent.prototype.$api = Api\r\n", "export", " ", "default", " Api ", "as", " any\r\n\r\n\r\n复制代码", "注：", "在这里tslint会报这样的错： ", "类型“Component<any, any>”上不存在属性“$api”", " 。，因为没有添加声明，需在./src目录下创建 ", "app-shim.d.ts", "/** \r\n * 添加taro等自定义类型\r\n*/", "\r\n\r\n", "import", " Taro,{ Component } from ", "'@tarojs/taro'", "\r\n\r\n", "// 在Component上定义自定义方法类型", "\r\n", "declare", " ", "module", " '@tarojs/taro' {\r\n    ", "interface", " Component {\r\n        $api: ", "any", "\r\n    }\r\n}\r\n\r\n", "// 声明", "\r\n", "declare", " ", "let", " ", "require", ": ", "any", ";\r\n", "declare", " ", "let", " dispatch: ", "any", "\r\n\r\n复制代码", "8、在 ", "./src/config", " 下创建taroConfig.ts，封装taro小程序的一些方法", "import", " Taro,{ Component } ", "from", " ", "'@tarojs/taro'", "\r\n", "import", " { SHAREINFO } ", "from", " ", "'../config/index'", "\r\n\r\n\r\n\r\n", "/** \r\n * 封装taro小程序的一些方法\r\n *  - 方法改写\r\n *  - utils 挂载\r\n*/", "\r\n\r\n\r\n", "// navigateTo 超过8次后，强行进行redirectTo,避免页面卡顿", "\r\n\r\n ", "const", " nav = Taro.navigateTo\r\n Taro.navigateTo = ", "(", "data", ") =>", " {\r\n     ", "if", " (Taro.getCurrentPages().length > ", "8", ") {\r\n         ", "return", " Taro.redirectTo(data)\r\n     }\r\n     ", "return", " nav(data)\r\n }\r\n\r\n\r\n", "// 挂载分享方法 Component", "\r\n\r\nComponent.prototype.onShareAppMessage = ", "function", " (", ") ", "{\r\n    ", "return", " SHAREINFO\r\n}\r\n\r\n\r\n复制代码", "配置文件生成脚本", "1、在根目录下创建scripts文件夹，添加 ", "./scripts/template.js", "/** \r\n *  pages 页面快速生成脚本\r\n *  \r\n *  npm run tem '文件名‘\r\n*/", "\r\n\r\n", "const", " fs = require(", "'fs'", ")\r\n", "const", " dirName = process.argv[", "2", "]\r\n", "const", " capPirName = dirName.substring(", "0", ", ", "1", ").toUpperCase() + dirName.substring(", "1", ");\r\n\r\n", "if", " (!dirName) {\r\n    console.log(", "'文件名不能为空'", ");\r\n    console.log(", "'用法：npm run tem test'", ");\r\n    process.exit(", "0", ");\r\n}\r\n\r\n", "// 页面模板构建", "\r\n\r\n", "const", " indexTep = `\r\n    ", "import", " Taro, { Component, Config } from ", "'@tarojs/taro'", "\r\n    ", "import", " { View } from ", "'@tarojs/components'", "\r\n    ", "// import { connect } from '@tarojs/redux'", "\r\n    ", "// import Api from '../../utils/request'", "\r\n    ", "// import Tips from '../../utils/tips'", "\r\n    ", "import", " { ${capPirName}Props, ${capPirName}State } from ", "'./", "${dirName}", ".interface'", "\r\n    ", "import", " ", "'./", "${dirName}", ".scss'", "\r\n    ", "// import {  } from '../../components'", "\r\n\r\n    ", "// @connect(({ ${dirName} }) => ({", "\r\n    ", "//     ...${dirName},", "\r\n    ", "// }))", "\r\n\r\n    ", "class", " $", "{capPirName} ", "extends", " Component<${capPirName}Props,${capPirName}State > {\r\n    config:Config = {\r\n        navigationBarTitleText: ", "'页面标题'", "\r\n    }\r\n    constructor(props: ${capPirName}Props) {\r\n        ", "super", "(props)\r\n        ", "this", ".state = {}\r\n    }\r\n\r\n    componentDidMount() {\r\n        \r\n    }\r\n\r\n    render() {\r\n        ", "return", " (\r\n        <View className=", "'fx-", "${dirName}", "-wrap'", ">\r\n            页面内容\r\n        </View>\r\n        )\r\n    }\r\n    }\r\n    ", "export", " ", "default", " ${capPirName}\r\n`\r\n\r\n", "// scss 文件模板", "\r\n\r\n", "const", " scssTep = `\r\n    ", "@import", " ", "\"../../assets/scss/variables\"", ";\r\n    .#{$prefix} {\r\n        &-${dirName}-wrap {\r\n            width: ", "100", "%;\r\n            min-height: ", "100", "Vh;\r\n        }\r\n    }\r\n`\r\n\r\n", "// config 接口地址配置模板", "\r\n\r\n", "const", " configTep =`\r\n    ", "export", " ", "default", " {\r\n        test:", "'/wechat/perfect-info'", ",  ", "//XX接口", "\r\n    }\r\n`\r\n\r\n", "// 接口请求模板", "\r\n\r\n", "const", " serviceTep =`\r\n    ", "import", " Api from ", "'../../utils/request'", "\r\n    ", "export", " ", "const", " testApi = data => Api.test(\r\n        data\r\n    )\r\n`\r\n\r\n", "// model 模板", "\r\n\r\n", "const", " modelTep = `\r\n    ", "// import Taro from '@tarojs/taro';", "\r\n    ", "// import * as ${dirName}Api from './service';", "\r\n    ", "export", " ", "default", " {\r\n        namespace: ", "'", "${dirName}", "'", ",\r\n        state: {\r\n        },\r\n        \r\n        effects: {},\r\n        \r\n        reducers: {}\r\n    \r\n    }\r\n\r\n`\r\n\r\n", "const", " interfaceTep = `\r\n", "/**\r\n * ${dirName}.state 参数类型\r\n *\r\n * @export\r\n * @interface ${capPirName}State\r\n */", "\r\n", "export", " ", "interface", " $", "{capPirName}State {}\r\n\r\n", "/**\r\n * ${dirName}.props 参数类型\r\n *\r\n * @export\r\n * @interface ${capPirName}Props\r\n */", "\r\n", "export", " ", "interface", " $", "{capPirName}Props {}\r\n`\r\n\r\nfs.mkdirSync(`./src/pages/${dirName}`); ", "// mkdir $1", "\r\nprocess.chdir(`./src/pages/${dirName}`); ", "// cd $1", "\r\n\r\nfs.writeFileSync(`${dirName}.tsx`, indexTep); ", "//tsx", "\r\nfs.writeFileSync(`${dirName}.scss`, scssTep); ", "// scss", "\r\nfs.writeFileSync(", "'config.ts'", ", configTep); ", "// config", "\r\nfs.writeFileSync(", "'service.ts'", ", serviceTep); ", "// service", "\r\nfs.writeFileSync(", "'model.ts'", ", modelTep); ", "// model", "\r\nfs.writeFileSync(`${dirName}.interface.ts`, interfaceTep); ", "// interface", "\r\nprocess.exit(", "0", ");\r\n\r\n\r\n\r\n复制代码", "最后", "在根目录的 ", "package.json", " 的scripts里加上对应的命令", "\"scripts\"", ": {\r\n  ...\r\n  ", "\"tep\"", ": ", "\"node scripts/template\"", ",\r\n  ", "\"com\"", ": ", "\"node scripts/component\"", "\r\n}\r\n\r\n复制代码", "2、自动生成脚本文件夹", "cnpm run tep index", "page文件夹下生成了一个index的文件夹，里面包含", "config.ts", "index.interface.ts", "index.scss", "index.tsx", "model.ts", "service.ts", "配置业务代码", "1、先在 ", "src", " 目录下创建 ", "models", " 文件夹，集合项目里的 ", "model", " 关系。", "import ", "index", " from ", "'../pages/index/model'", ";\r\n\r\n\r\n", "export", " ", "default", "[\r\n    ", "index", "\r\n]\r\n\r\n复制代码", "项目目前只有 ", "index", " 页面， ", "export default", " 这里的数组就只有 ", "index", " ，需要注意这里是 ", "[]", "数组。", "2、修改非常主要的文件 ", "app.tsx", "import", " Taro, { Component, Config } ", "from", " ", "'@tarojs/taro'", "\r\n", "import", " ", "\"@tarojs/async-await\"", ";\r\n", "import", " { Provider } ", "from", " ", "\"@tarojs/redux\"", ";\r\n", "import", " dva ", "from", " ", "'./utils/dva'", ";\r\n", "import", " ", "'./utils/request'", ";\r\n", "import", " { globalData } ", "from", " ", "'./utils/common'", ";\r\n\r\n", "import", " models ", "from", " ", "'./models'", "\r\n", "import", " Index ", "from", " ", "'./pages/index'", "\r\n", "import", " ", "'./app.scss'", "\r\n\r\n", "// 如果需要在 h5 环境中开启 React Devtools", "\r\n", "// 取消以下注释：", "\r\n", "// if (process.env.NODE_ENV !== 'production' && process.env.TARO_ENV === 'h5')  {", "\r\n", "//   require('nerv-devtools')", "\r\n", "// }", "\r\n\r\n\r\n", "const", " dvaApp = dva.createApp({\r\n  ", "initialState", ":{},\r\n  ", "models", ":  models,\r\n})\r\n\r\n", "const", " store = dvaApp.getStore();\r\n\r\n", "class", " ", "App", " ", "extends", " ", "Component", " ", "{\r\n\r\n  ", "/**\r\n   * 指定config的类型声明为: Taro.Config\r\n   *\r\n   * 由于 typescript 对于 object 类型推导只能推出 Key 的基本类型\r\n   * 对于像 navigationBarTextStyle: 'black' 这样的推导出的类型是 string\r\n   * 提示和声明 navigationBarTextStyle: 'black' | 'white' 类型冲突, 需要显示声明类型\r\n   */", "\r\n  config: Config = {\r\n    ", "pages", ": [\r\n      ", "'pages/index/index'", "\r\n    ],\r\n    ", "window", ": {\r\n      ", "backgroundTextStyle", ": ", "'light'", ",\r\n      ", "navigationBarBackgroundColor", ": ", "'#fff'", ",\r\n      ", "navigationBarTitleText", ": ", "'WeChat'", ",\r\n      ", "navigationBarTextStyle", ": ", "'black'", "\r\n    }\r\n  }\r\n\r\n  ", "/**\r\n   *\r\n   *  1.小程序打开的参数 globalData.extraData.xx\r\n   *  2.从二维码进入的参数 globalData.extraData.xx\r\n   *  3.获取小程序的设备信息 globalData.systemInfo\r\n   */", "\r\n  ", "async", " componentDidMount () {\r\n    ", "// 获取参数", "\r\n    ", "const", " referrerInfo = ", "this", ".$router.params.referrerInfo\r\n    ", "const", " query = ", "this", ".$router.params.query\r\n    !globalData.extraData && (globalData.extraData = {})\r\n    ", "if", " (referrerInfo && referrerInfo.extraData) {\r\n      globalData.extraData = referrerInfo.extraData\r\n    }\r\n    ", "if", " (query) {\r\n      globalData.extraData = {\r\n        ...globalData.extraData,\r\n        ...query\r\n      }\r\n    }\r\n\r\n    ", "// 获取设备信息", "\r\n    ", "const", " sys = ", "await", " Taro.getSystemInfo()\r\n    sys && (globalData.systemInfo = sys)\r\n  }\r\n\r\n  componentDidShow () {}\r\n\r\n  componentDidHide () {}\r\n\r\n  componentDidCatchError () {}\r\n\r\n  render () {\r\n    ", "return", " (\r\n      ", "<", "Provider", " ", "store", "=", "{store}", ">", "\r\n        ", "<", "Index", " />", "\r\n      ", "</", "Provider", ">", "\r\n    )\r\n  }\r\n}\r\n\r\nTaro.render(", "<", "App", " />", ", document.getElementById('app'))\r\n\r\n\r\n复制代码", "3、修改接口请求 ", "./src/pages/index/config.ts", " 文件", "一个获取列表数据接口", "export", " ", "default", " {\r\n  ", "getList", ": ", "'/getlist'", ", //getlist接口\r\n}\r\n\r\n复制代码", "4、修改 ", "./src/config/requestConfig.ts", " 文件的映射关系", "引入 ", "index", " 页面的刚刚创建的 ", "config", " 文件", "import", " index ", "from", " ", "\"../pages/index/config\"", "; ", "// index的接口", "\r\n\r\n\r\n\r\n", "/** \r\n * 请求公共参数\r\n*/", "\r\n", "export", " ", "const", " commonParame = {}\r\n\r\n", "/** \r\n * 请求的映射文件\r\n*/", "\r\n\r\n", "export", " ", "const", " requestConfig = {\r\n    ", "loginUrl", ":", "'/api/user/wechat-auth'", ", ", "// 微信的登陆接口", "\r\n    ...index\r\n}\r\n\r\n\r\n复制代码", "5、修改 ", "./src/pages/index/service.ts", " 里的接口请求", "还是依据之前的 ", "getlist", " 接口", "import", " Api ", "from", " ", "'../../utils/request'", "\r\n\r\n", "export", " ", "const", " getList = ", "(", "data", ") =>", " {\r\n\r\n  ", "return", " Api.getList(data)\r\n\r\n}\r\n  \r\n\r\n复制代码", "6、修改 ", "./src/pages/index/index.interface.ts", " 里的参数类型", "根据项目具体的参数，自行进行配置", "/**\r\n * index.state 参数类型\r\n * @interface IndexState\r\n */", "\r\n", "export", " ", "interface", " IndexState {\r\n\r\n}\r\n\r\n", "/**\r\n * index.props 参数类型\r\n *\r\n * @export\r\n * @interface IndexProps\r\n */", "\r\n", "export", " ", "interface", " IndexProps {\r\n    dispatch?: ", "any", ",\r\n    data?: ", "Array", "<DataInterface>\r\n}\r\n\r\n", "export", " ", "interface", " DataInterface {\r\n    des:", "string", ",\r\n    lunar:", "string", ",\r\n    thumbnail_pic_s:", "string", ",\r\n    title:", "string", ",\r\n    _id:", "string", "\r\n}\r\n\r\n复制代码", "7、修改 ", "./src/pages/index/model.ts", " 里 ", "effects", " 函数", "在这里创建页面需要请求的接口，链接 ", "service", " 里的接口发起数据请求,这里以 ", "getList", " 为例。", "// ", "import", " Taro from ", "'@tarojs/taro'", ";\r\n", "import", " * ", "as", " indexApi from ", "'./service'", ";\r\n\r\nexport ", "default", " {\r\n  namespace: ", "'index'", ",\r\n  state: {\r\n    data:[],\r\n    v:", "'1.0'", ",\r\n  },\r\n\r\n  effects: {\r\n    *getList({ payload },{select, call, put}){\r\n      const { error, result} = yield call(indexApi.getList,{\r\n        ...payload\r\n      })\r\n      console.log(", "'数据接口返回'", ",result);\r\n      \r\n      if (!error) {\r\n        yield put({\r\n          type: ", "'save'", ",\r\n          payload: {\r\n            data:result.data\r\n          },\r\n        })\r\n      }\r\n    }\r\n  },\r\n\r\n  reducers: {\r\n    save(state, { payload }) {\r\n      return { ...state, ...payload };\r\n    },\r\n  }\r\n\r\n}\r\n\r\n复制代码", "8、修改 ", "./src/pages/index/index.tsx", " 里页面结构", "这里简单的实现列表新闻页面。", "import", " Taro, { Component, Config } ", "from", " ", "'@tarojs/taro'", "\r\n", "import", " { View, Text} ", "from", " ", "'@tarojs/components'", "\r\n", "import", " { connect } ", "from", " ", "'@tarojs/redux'", "\r\n", "// import Api from '../../utils/request'", "\r\n", "// import Tips from '../../utils/tips'", "\r\n", "import", " { IndexProps, IndexState } ", "from", " ", "'./index.interface'", "\r\n", "import", " ", "'./index.scss'", "\r\n", "// import {  } from '../../components'", "\r\n\r\n@connect(", "(", "{ index }", ") =>", " ({\r\n    ...index,\r\n}))\r\n\r\n", "class", " ", "Index", " ", "extends", " ", "Component", "<", "IndexProps", ",", "IndexState", " > ", "{\r\n  config:Config = {\r\n    ", "navigationBarTitleText", ": ", "'taro_dva_typescript'", "\r\n  }\r\n  ", "constructor", "(props: IndexProps) {\r\n    ", "super", "(props)\r\n    ", "this", ".state = {}\r\n  }\r\n\r\n  ", "async", " getList() {\r\n    ", "await", " ", "this", ".props.dispatch({\r\n      ", "type", ": ", "'index/getList'", ",\r\n      ", "payload", ": {}\r\n    })\r\n  }\r\n\r\n  componentDidMount() {\r\n    ", "this", ".getList()\r\n  }\r\n\r\n  render() {\r\n    ", "const", " { data } = ", "this", ".props\r\n    ", "console", ".log(", "'this.props===>>'", ",data);\r\n    \r\n    ", "return", " (\r\n      ", "<", "View", " ", "className", "=", "'fx-index-wrap'", ">", "\r\n          ", "<", "View", " ", "className", "=", "'index-topbar'", ">", "New资讯", "</", "View", ">", "\r\n          ", "<", "View", " ", "className", "=", "'index-data'", ">", "\r\n            {\r\n              data && data.map((item,index) => {\r\n                return (\r\n                  ", "<", "View", " ", "className", "=", "'index-list'", " ", "key", "=", "{index}", ">", "\r\n                    ", "<", "View", " ", "className", "=", "'index-title'", ">", "{item.title}", "</", "View", ">", "\r\n                    ", "<", "View", " ", "className", "=", "'index-img'", " ", "style", "=", "{", "`", "background-image:", " ", "url", "(${", "item.thumbnail_pic_s", "})`}>", "</", "View", ">", "\r\n                  ", "</", "View", ">", "\r\n                )\r\n              })\r\n            }\r\n          ", "</", "View", ">", "\r\n      ", "</", "View", ">", "\r\n    )\r\n  }\r\n}\r\n\r\n", "export", " ", "default", " Index\r\n\r\n\r\n复制代码", "9、修改 ", "./src/pages/index/index.scss", " 首页的样式", "这里的写法是 ", "sass", " 的语法糖", "@", "import", " ", "\"../../assets/scss/variables\"", ";\r\n\r\n.#{", "$prefix", "} {\r\n\r\n  &-index-wrap {\r\n    ", "width", ": ", "100%", ";\r\n    ", "min-height", ": ", "100vh", ";\r\n    ", ".index", " {\r\n      &-topbar {\r\n        ", "padding", ": ", "10", "rpx ", "50", "rpx;\r\n        ", "text-align", ": center;\r\n        ", "font-weight", ": bold;\r\n        ", "color", ": ", "#333", ";\r\n        ", "font-size", ": ", "30", "rpx;\r\n      }\r\n  \r\n      ", "// &-data {", "\r\n      ", "// }", "\r\n       \r\n      &-", "title", " {\r\n        ", "font-size", ": ", "28", "rpx;\r\n        ", "color", ": ", "#666", ";\r\n        ", "width", ": ", "100%", ";\r\n        ", "font-weight", ": bold;\r\n      }\r\n      &-list{\r\n        ", "border-bottom", ": ", "1", "rpx solid ", "#eee", ";\r\n        ", "padding-bottom", ": ", "20", "rpx;\r\n        ", "margin", ": ", "20", "rpx ", "24", "rpx;\r\n        ", "display", ": flex;\r\n        ", "flex-direction", ": row;\r\n        ", "justify-content", ": space-between;\r\n        ", "align-items", ": center\r\n      }\r\n  \r\n      &-img {\r\n        width: ", "70%", ";\r\n        ", "height", ": ", "200", "rpx;\r\n        ", "background-repeat", ": no-repeat;\r\n        ", "background-size", ": contain;\r\n        ", "background-position", ": right center;\r\n      }\r\n    }\r\n  }\r\n \r\n}\r\n\r\n\r\n复制代码", "项目启动", "运行小程序编译命令", "cnpm run dev:weapp", "等待项目编译完成，会在项目根目录下生成一个 ", "dist", " ,打开微信小程序开发者根据，导入本地刚刚生成的 ", "dist", " 文件，就成功启动了项目。", "效果预览图：", "如有啥问题欢迎讨论，共同学习。", "项目示例Github地址： ", "github.com/Duanruilong…", " "]}
{"title": "基于 Vue 的小程序开发框架性能优化实践---去除 VNode ", "author": "Rolan", "pub_time": "2019-7-30 00:41", "content": [" \n                     \n                    ", "为了提高", "小程序", "的开发效率，我们团队开发了", "Mars 框架", "，可以使用 Vue 语法开发小程序，同时支持编译到 H5。近期我们进行了 Mars 框架的性能升级（", "0.3.x 版本", "），极大简化了 Vue 的 render 过程，去掉了 VNode 构建，省略了 patch 过程，从而获得了性能提升。", "\r\n\r\n", "Mars 框架原理简介，为什么要去除 VNode？", "\r\n", "为了方便大家理解，这里简单说一下 Mars 框架的原理，目前基于 Vue 的小程序开发框架原理差异不大。", "\r\n", "\r\n", "详细的原理大家可以看这篇文章：", "Mars - 又双叒叕一个多端开发框架？这次是 Vue 驱动，能完美适配 H5", "\r\n", "\r\n", "Mars 的原理如下图所示：", "\r\n", "\r\n", "上图中，左半部分表示小程序的执行部分。粉红色区域代表小程序视图，蓝色部分代表小程序的逻辑执行部分，视图与逻辑之间交换的是数据和事件。右边绿色部分是我们在小程序逻辑之外，单独创建的 Vue 实例。小程序逻辑（蓝色部分）与 Vue 实例（绿色部分）是以如下方式工作的：", "\r\n", "\r\n", "在小程序的 Page 创建时，我们会同步 new 一个 Vue 实例。", "\r\n", "在 Vue 实例的 ", ".$mp.scope", " 变量中绑定小程序实例，小程序实例中也会使用 ", ".$vue", " 变量来绑定 Vue 实例，用于后续的数据传递。", "\r\n", "使用 ", "handleProxy", " 方法代理小程序中的事件，当小程序事件发生时，对应执行 Vue 实例中相应的 Method。", "\r\n", "页面中的逻辑执行在 Vue 部分，每当 Vue 的视图更新时，在 Updated 阶段将数据的变化使用 ", "setData", " 方法同步给小程序实例，触发小程序视图的刷新。", "\r\n", "\r\n", "可以看到", "优化前", "我们基本保留了 Vue 的所有渲染过程，只是删除了 Vue 中的 DOM 操作部分。由于 Vue 实例与小程序之间交换的只有数据，因此 Vue 中的视图层其实是没有用到的。\r\n我们需要的只是", "执行 Vue 中的逻辑，判断数据修改是否会造成视图更新，视图更新时把变化的数据同步给小程序", "。而 Vue 视图层相关的内容，VNode、render、patch 这些很多是没有必要的，我们的想法是通过精简不必要的操作来提升性能。", "\r\n", "优化前 render 和 patch 过程所起的作用", "\r\n", "想要精简 render 和 patch，我们就需要先搞清楚 render 和 patch 在 Vue 中起到了什么作用：", "\r\n", "\r\n", "在 Vue 中，当数据发生变化时，会通知视图渲染依赖这一数据的所有实例，依次执行这些实例的 render 函数，这次 render 函数执行过程中又会重新收集依赖，用于下一次数据发生变化时的依赖追踪。", "\r\n", "render 函数执行后会返回一个该实例对应的 VNode 树，", "render 过程中并不会创建子组件实例", "，仅仅是生成了一个占位符。这个 VNode 树随后会传递给 patch 过程。", "\r\n", "patch 过程会将当前 VNode 树与旧 VNode 树进行 diff，之后根据 diff 创建、销毁子组件实例，修改 DOM 完成渲染。", "\r\n", "\r\n", "在小程序框架这个情境下，我们需要的是 ", "数据依赖追踪", " 和 ", "组件实例创建、销毁", "，其他部分的内容则可以进行删减。", "\r\n", "我们可以精简哪些内容？", "\r\n", "\r\n", "render 函数部分", "，我们只需要进行必要的依赖追踪，不需要创建 VNode 节点。", "\r\n", "patch 部分", "，由于没有 VNode 了，我们也不需要进行耗时的 diff 操作了！", "\r\n", "\r\n", "但是等一下，没有了 VNode 树，如何创建组件实例呢？", "我们将子组件的 Vue 实例创建改到了小程序子组件的生命周期中", "，也就是说单个 Vue 实例只会创建它自己，不会在继续创建子组件实例。\r\n之前的结构为小程序实例树和 Vue 实例树，组件实例间互相绑定。现在的结构变为只有小程序实例树，每个小程序实例节点单独对应一个 Vue 实例。", "\r\n", "开始实践！", "\r\n", "下面介绍一下我们具体做了哪些内容。", "\r\n", "createComponent 中创建 Vue 实例", "\r\n", "由于把 patch 过程干掉了，因此我们需要手动创建子组件的 Vue 实例，同 Page 一样，我们在 Component 的生命周期函数中 new 一个 Vue 实例，并与当前小程序实例绑定：", "\r\n", "this", ".$vue = ", "new", " VueComponent(options);\r\n", "this", ".$vue.$mp = {\r\n    ", "scope", ": ", "this", "\r\n};\r\n", "复制代码", "在组件中创建 Vue 实例时，之前 Vue 中的父子关系没有了，维护这一关系需要解决以下问题：", "父元素绑定", "、", "properties 传递", "。", "\r\n", "父元素绑定", "\r\n", "在 patch 过程中，Vue 创建子组件时会传递以下三个参数：", "\r\n", "const", " options: InternalComponentOptions = {\r\n    ", "_isComponent", ": ", "true", ",\r\n    ", "_parentVnode", ": vnode,\r\n    parent\r\n}\r\n", "复制代码", "\r\n", "_isComponent", " 用于优化 options 的合并，我们可以直接设置成 true。", "\r\n", "_parentVnode", " 用于在 render 过程中获取父元素信息，例如 scope-slot 等，由于我们已经把 VNode 删掉了，因此不再需要了。", "\r\n", "parent", " 用于获取根元素、绑定 $children 等操作，Vue 就是通过这个参数来维护实例间的父子关系的。", "\r\n", "\r\n", "我们需要找到当前 Vue 实例的父实例，作为 parent 参数，从而完成父元素绑定过程。\r\n小程序当前没有机制来直接获取父元素，需要我们自己想办法来查找。在之前开发 Mars 过程中，为了进行小程序组件实例和 Vue 组件实例间的匹配，对小程序实例树和 Vue 实例树中的组件节点都进行了标记，现在不需要进行实例间匹配查找了，但是我们可以通过这个标记来查找父元素。", "\r\n", "\r\n", "由于 Page 元素可能在同一时间不唯一（由于页面切换），因此每创建一个 Page 实例，都需要绑定一个唯一的 rootUID，我们将其存储在了", "getApp().__pages__", "中。rootUID 会逐层传给每个小程序自定义组件实例。", "\r\n", "每次有小程序自定义组件实例创建，我们都将该实例以标记的 id 为 key 存储在 ", "getApp().__pages__[rootUID].__vms__", "中。", "\r\n", "根据 rootUID 找到根元素，进而找到 page 中的 ", "__vms__", "。", "\r\n", "根据 compId 算出父实例的 compId。", "\r\n", "根据父实例的 compid从", "__vms__", "中找到父元素，作为 parent。", "\r\n", "\r\n", "properties 传递", "\r\n", "除了需要设置的初始化属性外，我们还需要传递子组件的 properties，否则父元素的数据没办法传递给子组件。", "\r\n", "\r\n", "\r\n", "数据初始化", "：可以在 Vue 创建时传入 ", "propsData", " 来作为 props 的初始数据。\r\n由于小程序自定义组件的参数和 Vue 子组件实例的参数是相同的，因此我们可以直接将程序自定义组件的参数作为", "propsData", "在 new Vue 时传入：", "\r\n", "const", " options = {\r\n    ", "mpType", ": ", "'component'", ",\r\n    ", "mpInstance", ": ", "this", ",\r\n    ", "propsData", ": properties,\r\n    parent\r\n};\r\n\r\n", "// 初始化 vue 实例", "\r\n", "this", ".$vue = ", "new", " VueComponent(options);\r\n", "复制代码", "\r\n", "\r\n", "数据更新", "：仿照 Vue 给子组件传参数的机制，每次 render 时，将 props 重新给子组件赋值一遍。", "\r\n", "\r\n", "\r\n", "\r\n", "只需要更新第一层，因为 properties 如果是对象，那么它在父元素中已经做过变化追踪了。", "\r\n", "\r\n", "事件传递", "\r\n", "对于 template 上绑定的事件，由于我们本身已经使用了 ", "handleProxy", " 来处理，因此不会受到影响。", "\r\n", "需要处理的是 ", ".$emit", "、", ".$on", " 方法。", "\r\n", "\r\n", "对于 ", ".$emit", "，我们利用小程序机制，使用 ", "triggerEvent", " 在小程序层面给父元素传递事件。", "\r\n", "对于 ", ".$on", "，使用 Vue 现成的机制就好，不需要做额外工作，不过这也造成 Vue 的事件机制不能删除。", "\r\n", "\r\n", "\r\n", "这里有个小坑：triggerEvent 方法传递的参数，需要从 event.detail 中获取，Mars 兼容了这个 diff。", "\r\n", "\r\n", "render 函数精简", "\r\n", "render 函数目前我们不能完全删除，因为需要以下两个功能：", "依赖收集", "、", "复杂表达式和filter 计算", "。", "\r\n", "依赖收集", "\r\n", "Vue 在初始化时会对实例上的 data 进行响应式处理，设置 set 和 get 方法。组件执行 render 函数时，会读取变量触发 get 方法，从而在 get 方法中将当前实例收集为这个数据的依赖。下次数据更新时 Vue 会通知依赖进行更新。", "\r\n", "为了收集依赖，我们需要在 render 函数中读取一遍数据。这里我们将 VNode 树编译为数组树的形式，只留下数据，剩下的内容都可以删除。", "\r\n", "比如这样的一个 template:", "\r\n", "<", "template", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"hello\"", ">", "\r\n        ", "<", "view", " @", "tap", "=", "\"tapHandler\"", ">", "\r\n            ", "<", "text", ">", "https://github.com/max-team/Mars", "</", "text", ">", "\r\n        ", "</", "view", ">", "\r\n        ", "<", "view", ">", "{{ aaa }}", "</", "view", ">", "\r\n        ", "<", "view", ">", "{{ ccc }}", "</", "view", ">", "\r\n        ", "<", "name", " ", ":name", "=", "\"nameOutter\"", ">", "</", "name", ">", "\r\n        ", "<", "view", ">", "{{ aaaComp }}", "</", "view", ">", "\r\n    ", "</", "view", ">", "\r\n", "</", "template", ">", "\r\n", "复制代码", "Vue 产出的 render 函数是这样的：", "\r\n", "// 修改前的 render 函数", "\r\n_c(", "'view'", ",{", "staticClass", ":", "\"hello\"", "},[_c(", "'view'", ",{", "on", ":{", "\"tap\"", ":_vm.tapHandler}},[_c(", "'text'", ",[_vm._v(", "\"https://github.com/max-team/Mars\"", ")])]),_c(", "'view'", ",[_vm._v(_vm._s(_vm.aaa))]),_c(", "'view'", ",[_vm._v(_vm._s(_vm.ccc))]),_c(", "'name'", ",{", "attrs", ":{", "\"name\"", ":_vm.nameOutter,", "\"compId\"", ":(_vm.compId ? _vm.compId : ", "'$root'", ") + ", "',0'", "}}),_c(", "'view'", ",[_vm._v(_vm._s(_vm.aaaComp))])],", "1", ")\r\n", "复制代码", "精简后我们得到的 render 函数是这样的：", "\r\n", "// 修改后的 render 函数", "\r\n[,[,,[(_vm.aaa)],,[(_vm.ccc)],,[[_vm.nameOutter,(_vm.compId ? _vm.compId : ", "'$root'", ") + ", "',0'", "]],,[(_vm.aaaComp)]]]\r\n", "复制代码", "可以看到 Vue 中的大量 render helper 掉用，例如 ", "_c", "、", "_v", "、", "_s", " 等都可以省略了。", "\r\n", "\r\n", "有些 render helper 还是不能去掉，例如 v-for 循环，我们还是保留了 _l 函数，因为 v-for 循环的对象可能为数组、字符串、数字等多种情况。", "\r\n", "\r\n", "复杂表达式和filter 计算。", "\r\n", "在 Vue 的 template 中，是可以像 js 一样执行很多计算的，比如可以执行定义好的 method：", "\r\n", "<", "div", " ", ":prop", "=", "\"someMethod(data)\"", ">", "</", "div", ">", "\r\n", "复制代码", "或者执行一个 filter", "\r\n", "<", "div", " ", ":prop", "=", "\"someMethod | someFilter\"", ">", "</", "div", ">", "\r\n", "复制代码", "这部分的计算之前是在 render 中随着 VNode 构建执行的，计算结果存储在了 VNode 节点中。现在我们没有 VNode 了，计算出的值怎么办呢？", "\r\n", "\r\n", "计算复杂表达式和 filter 的过程还在 render 过程中保留。", "\r\n", "计算出的值使用 ", "_ff", " 方法包裹。每个计算值产生一个唯一的 id，", "_ff", " 方法将这些值按照 id 存储下来 setData 给小程序，小程序直接使用这些计算结果来进行渲染。", "\r\n", "\r\n", "patch 过程", "\r\n", "patch 过程已经完全不需要了，我们将这一过程完全删除。", "\r\n", "顺带解决的一个坑", "\r\n", "在之前的方案中，从 Page 开始创建的小程序组件实例树，与 Vue 组件实例树是相互独立的。为了让小程序组件实例与 Vue 组件实例之间能够对应上（否则无法在组件级别 setData），我们需要对每个组件实例进行标记，通过标记来寻找对应关系。这在一些特殊情景下是会有问题的，例如组件快速生成又销毁等，造成实例间不匹配。", "\r\n", "修改后的方案由于 Vue 实例是以组件级别创建的了，因此不再会出现实例无法匹配的情况。", "\r\n", "结果和总结", "\r\n", "我们使用了线上业务进行验证，渲染时间 -16%。此外，由于我们精简了 Vue 的功能，删除了这部分功能的代码，框架整体的体积也减少了 11%。", " "]}
{"title": "电视剧看多了，就想仿个爱奇艺小程序 ", "author": "Rolan", "pub_time": "2019-8-1 00:33", "content": [" \n                     \n                    ", "\r\n", "听说讲正文前，都喜欢先唠会嗑，咱们先聊个五毛钱的，不知道大家最近有没有看啥电视剧，比如，emmmmm，《亲爱的，热爱的》(斜眼笑)(好的假装你们看过了，咱们可以接着聊了)。哇，杨紫小猴子超甜的有没有，老夫的少女心，比吃了蜜还甜，李现大概或许可能maybe比我帅那么一丢丢，就一丢丢(是在下不要脸了，请忽略上面这句话谢谢！！！)。用爱奇艺看多了，就想仿个爱奇艺", "小程序", "来练练手(那是因为爱奇艺APP那玩意儿暂时还仿不出来)，虽说自己比较菜，写的不怎么样，但是咱们搞技术的，总得折腾一下嘛，有兴趣的东西就应该撸一个出来。好了五毛钱的聊完了，该讲正题了，还想聊天的再加五毛，一块也行，在座的各位都是大佬，多多指点一下下哈!蟹蟹蟹蟹。", "\r\n", "效果展示", "\r\n", "\r\n", "\r\n", "\r\n", "项目前准备", "\r\n", "\r\n", "VS Code", "\r\n", "微信web开发者工具以及它的云开发", "\r\n", "微信开放文档", "\r\n", "easymock", "\r\n", "Vant Weapp", "\r\n", "iconfont", "\r\n", "还有就是数据，有点伤感难过，数据自己在爱奇艺官网一个个找的，所以小程序里面的数据有一(da)部分是重复的，咱也不敢说，咱也不敢问(等我学会了爬虫，再去爬你几千条数据解解气)", "\r\n", "\r\n", "项目界面", "\r\n", "首页", "\r\n", "\r\n", "首页长成这个样子，一眼看过去还是挺好写的，布局什么的都比较有规律，对于小白来说还是很友善的，没有花里胡哨的排列。头部用的是小程序官方的", "swiper", "组件,炒鸡好用。不过有一点就是，轮播图的指示点一般都是在中间靠下面一点，而正好这里有文字，会重叠，没有绿色的指示点(爱奇艺偏爱环保健康的green)又不好看，脑壳疼，咋办？加几行css就行了。", "\r\n", ".wx-swiper-dots {\r\n  position: relative;\r\n  left: ", "unset", " !important;\r\n  right: -40rpx;\r\n}\r\n.wx-swiper-dots.wx-swiper-dots-horizontal {\r\n  margin-bottom: -5rpx;\r\n}\r\n", "复制代码", "left不是可继承的样式，", "unset", "了之后，就相当于重置掉了，就可以开开心心的把指示点的位置换掉了。\r\n下面基本上就是一个  ", "wx:for", "能解决的事情，对于这样的布局，用", "flex", "是再好不过的了，简单方便又快捷，顺便给大家推荐一篇详细讲解", "flex", "的文章，看了说不定你也会收获一些东西。", "\r\n", "\r\nwxml", "\r\n", "<!-- miniprogram/pages/homepage/homepage.wxml -->\r\n<view class=", "\"homePage\"", ">\r\n  <view class=", "\"head\"", ">\r\n    <swiper indicator-dots=", "\"{{indicatorDots}}\"", " autoplay=", "\"{{autoplay}}\"", " interval=", "\"{{interval}}\"", " duration=", "\"{{duration}}\"", " indicator-color=", "\"{{indicatorColor}}\"", " indicator-active-color=", "\"{{indicatorActiveColor}}\"", " circular=", "\"{{circular}}\"", ">\r\n      <block wx:", "for", "=", "\"{{imgUrl}}\"", " wx:key=", "\"{{index}}\"", ">\r\n        <view bindtap=", "\"navigate\"", " data-set=", "\"{{item}}\"", ">\r\n          <swiper-item>\r\n            <image src=", "\"{{item.img}}\"", " mode=", "\"aspectFill\"", " class=", "\"slide-image\"", "></image>\r\n            <view class=", "\"desc\"", ">{{item.desc}}</view>\r\n          </swiper-item>\r\n        </view>\r\n      </block>\r\n    </swiper>\r\n    <view class=", "\"header\"", ">\r\n      <image class=", "\"iqiyi\"", " src=", "\"{{iqiyi}}\"", " mode=", "\"widthFix\"", " />\r\n      <view class=", "\"name\"", ">{{headerName}}</view>\r\n      <view class=", "\"searchBox\"", " bindtap=", "\"toSearch\"", ">\r\n        <icon class=", "\"iconSearch\"", " ", "type", "=", "\"search\"", " size=", "\"15\"", " color=", "\"rgb(47,244,44)\"", "></icon>\r\n        <view class=", "\"searchName\"", ">{{searchName}}</view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=", "\"content\"", ">\r\n    <view class=", "\"contentVideoes\"", " wx:", "for", "=", "\"{{videoes}}\"", " wx:key=", "\"index\"", ">\r\n      <!-- 板块标题 -->\r\n      <view class=", "\"title\"", ">{{item.listTitle}}</view>\r\n      <!-- 板块内容，四个内容 -->\r\n      <view class=", "\"contain\"", ">\r\n        <view class=", "\"video\"", " wx:", "for", "=", "\"{{item.videoList}}\"", " wx:key=", "\"index\"", " bindtap=", "\"navigate\"", " data-set=", "\"{{item}}\"", ">\r\n          <view class=", "\"topPart\"", ">\r\n            <image class=", "\"img\"", " src=", "\"{{item.img}}\"", " mode=", "\"widthFix\"", " />\r\n            <view class=", "\"count\"", ">{{item.count}}</view>\r\n            <view class=", "\"vip\"", " wx:", "if", "=", "\"{{item.vip}}\"", ">VIP</view>\r\n          </view>\r\n          <view class=", "\"downPart\"", ">\r\n            <view class=", "\"videoTitle\"", ">{{item.title}}</view>\r\n            <view class=", "\"videoDesc\"", ">{{item.desc}}</view>\r\n          </view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n</view>\r\n", "复制代码", "wxss", "\r\n", "/* miniprogram/pages/homepage/homepage.wxss */\r\n.homePage {\r\n  width: 100%;\r\n}\r\n.homePage .head {\r\n  position: relative;\r\n  width: 100%;\r\n}\r\n.homePage .head .slide-image {\r\n  width: 100%;\r\n}\r\n.homePage .head .desc {\r\n  position: absolute;\r\n  left: 20rpx;\r\n  bottom: 30rpx;\r\n  font-weight: bold;\r\n  font-size: 35rpx;\r\n  color: ", "#ffffff", "\r\n}\r\n.homePage .head .header {\r\n  width: 100%;\r\n  position: absolute;\r\n  top: 10rpx;\r\n  left: 10rpx;\r\n  display: flex\r\n}\r\n.homePage .head .header .iqiyi {\r\n  width: 75rpx;\r\n  display: inline-block;\r\n  top: 20rpx;\r\n  left: 10rpx;\r\n  margin: auto\r\n}\r\n.homePage .head .header .name {\r\n  font-size: 30rpx;\r\n  color: ", "#2BFA39;", "\r\n  font-weight: bold;\r\n  display: inline-block;\r\n  margin: auto\r\n}\r\n.homePage .head .header .searchBox {\r\n  flex: 1;\r\n  background-color: rgba(255,255,255,0.5);\r\n  border-radius: 42rpx;\r\n  margin: auto 30rpx;\r\n  height: 60rpx;\r\n  position: relative;\r\n}\r\n.homePage .head .header .searchBox .iconSearch {\r\n  margin: auto 20rpx;\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 20%;\r\n  transform: translate(-50%,-50%)\r\n}\r\n.homePage .head .header .searchBox .searchName {\r\n  display: inline-block;\r\n  font-size: 30rpx;\r\n  color: ", "#ffffff;", "\r\n  margin-left: 50%;\r\n  transform: translate(-50%,0)\r\n}\r\n\r\n\r\n.homePage .content {\r\n  width: 100%;\r\n}\r\n.homePage .content .contentVideoes {\r\n  padding-right: 15rpx;\r\n}\r\n.homePage .content .contentVideoes .title {\r\n  font-size: 35rpx;\r\n  font-weight: bold;\r\n  margin: 25rpx 0 25rpx 25rpx;\r\n}\r\n.homePage .content .contentVideoes .contain {\r\n  width: 100%;\r\n}\r\n.homePage .content .contentVideoes .contain .video {\r\n  display: inline-block;\r\n  width: 50%;\r\n  margin-bottom: 10px;\r\n  padding-left: 15rpx;\r\n  box-sizing: border-box\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart {\r\n  position: relative;\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .img {\r\n  display: block;\r\n  width: 100%; \r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .count {\r\n  position: absolute;\r\n  right: 15rpx;\r\n  bottom: 15rpx;\r\n  font-size: 25rpx;\r\n  color: ", "#fff;", "\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .vip {\r\n  position: absolute;\r\n  top: 0rpx;\r\n  right: 20rpx;\r\n  font-size: 25rpx;\r\n  background-color: ", "#E1B876;", "\r\n  color: ", "#FFF;", "\r\n  padding: 0rpx 10rpx 5rpx;\r\n  border-radius: 0 0 10rpx 10rpx;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart {\r\n  padding-right: 10rpx;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart .videoTitle {\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n  margin-bottom: 15rpx;\r\n  overflow:hidden;\r\n  text-overflow:ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart .videoDesc {\r\n  font-size: 25rpx;\r\n  margin-bottom: 20rpx;\r\n  color: ", "#999;", "\r\n  overflow: hidden;\r\n  text-overflow:ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.wx-swiper-dots {\r\n  position: relative;\r\n  left: ", "unset", " !important;\r\n  right: -40rpx;\r\n}\r\n\r\n.wx-swiper-dots.wx-swiper-dots-horizontal {\r\n  margin-bottom: -5rpx;\r\n}\r\n", "复制代码", "热点页", "\r\n", "\r\n", "小程序家的", "video", "组件，瞄一分钟文档，就能上手了。暖暖的，很贴心。", "\r\n", "<video src=", "\"{{ item.video}}\"", " duration=", "\"{{item.duration }}\"", " object-fit=", "\"cover\"", " id=", "\"{{ item.id}}\"", "  bindtap=", "\"handleVideoPlay\"", " data-vid=", "\"{{item.id}}\"", " ></video>\r\n", "复制代码", "小红心的切换则是根据从云数据库中取得的数据,动态切换。", "\r\n", "<image src=", "'{{item.isLike ? likeStar : star}}'", " class=", "'littleStar'", " mode=", "'aspectFit'", "></image>\r\n", "复制代码", "视频下面的布局就让万能的flex来解决叭。所以我决定送", "flex", "一朵花花。\r\n", "\r\nwxml", "\r\n", "<!-- miniprogram/pages/hot/hot.wxml -->\r\n<view class=", "'hotVideo'", ">\r\n  <view class=", "'video'", " wx:", "for", "=", "\"{{entities}}\"", " wx:key=", "\"id\"", " data-index=", "\"{{index}}\"", ">\r\n    <video src=", "\"{{ item.video}}\"", " duration=", "\"{{item.duration }}\"", " object-fit=", "\"cover\"", " id=", "\"{{ item.id}}\"", "  bindtap=", "\"handleVideoPlay\"", " data-vid=", "\"{{item.id}}\"", " ></video>\r\n    <view class=", "'title'", ">{{item.description}}</view>\r\n    <!-- 视频下面的用户信息以及视频热度和分享按钮,用一个盒子来包裹这些信息 -->\r\n    <view class=", "'infor'", ">\r\n      <view class=", "\"infor-left\"", ">\r\n        <image src=", "'{{item.userAvatar}}'", " class=", "'userAvatar'", " mode=", "\"aspectFit\"", "></image>\r\n        <view class=", "'userNickName'", ">{{item.userNickName}}</view>\r\n      </view>\r\n      <view class=", "\"infor-right\"", ">\r\n        <view class=", "'star'", " bindtap=", "\"wxLike\"", " data-index=", "\"{{index}}\"", " >\r\n          <image src=", "'{{item.isLike ? likeStar : star}}'", " class=", "'littleStar'", " mode=", "'aspectFit'", "></image>\r\n          <view class=", "'hotStar'", ">{{item.star}}</view>\r\n        </view>\r\n        <view class=", "'share'", " bindtap=", "\"wxShare\"", ">\r\n          <image src=", "'{{weixin}}'", " class=", "'wxLogo'", " mode=", "'aspectFit'", "></image>\r\n          <view class=", "'wxshare'", ">分享</view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <van-notify id=", "\"van-notify\"", " />\r\n  <van-toast id=", "\"van-toast\"", " />\r\n</view>\r\n", "复制代码", "wxss", "\r\n", "/* miniprogram/pages/hot/hot.wxss */\r\n.hotVideo {\r\n  width: 100%;\r\n}\r\n.hotVideo .video {\r\n  position: relative;\r\n}\r\n.hotVideo .video video{\r\n  width: 100%;\r\n  z-index: 5;\r\n}\r\n.hotVideo .video .title {\r\n  position: absolute;\r\n  top: 20rpx;\r\n  left: 20rpx;\r\n  z-index: 10;\r\n  color: ", "#fff;", "\r\n  font-size: 36rpx;\r\n  font-weight: bold;\r\n}\r\n.hotVideo .video .infor{\r\n  height: 125rpx;\r\n  position: relative;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-left {\r\n  height: 100%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-left .userAvatar {\r\n  width: 75rpx;\r\n  height: 75rpx;\r\n  margin: 20rpx 15px 30rpx 30rpx;\r\n  border-radius: 50%;\r\n  display: inline-block;\r\n}\r\n.hotVideo .video .infor .infor-left .userNickName {\r\n  display: inline-block;\r\n  line-height: 125rpx;\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n}\r\n.hotVideo .video .infor .infor-right {\r\n  flex: 1;\r\n  height: 100%;\r\n}\r\n.hotVideo .video .infor .infor-right .star {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid ", "#DDD;", "\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  right: 30%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-right .star .littleStar {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  ", "float", ": left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .infor-right .star .hotStar {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n.hotVideo .video .infor .infor-right .share {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid ", "#DDD;", "\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  right: 5%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-right .share .wxLogo {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  ", "float", ": left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .infor-right .share .wxshare {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n/* .hotVideo .video .infor{\r\n  height: 125rpx;\r\n  position: relative\r\n}\r\n.hotVideo .video .userAvatar {\r\n  width: 75rpx;\r\n  height: 75rpx;\r\n  ", "float", ": left;\r\n  margin: 20rpx 15px 40rpx 30rpx;\r\n  border-radius: 50%;\r\n}\r\n.hotVideo .video .userNickName {\r\n  line-height: 125rpx;\r\n  font-size: 27rpx;\r\n  display: inline-block;\r\n}\r\n.hotVideo .video .infor .star {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid ", "#DDD;", "\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  margin-left: 50%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .star .littleStar {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  ", "float", ": left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .star .hotStar {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n.hotVideo .video .infor .share {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid ", "#DDD;", "\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  margin-left: 75%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .share .weixin {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  ", "float", ": left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .share .wxshare {\r\n   line-height: 60rpx;\r\n   font-size: 30rpx;\r\n} */\r\n", "复制代码", "风云榜", "\r\n", "\r\n", "头部的横向滚动，在", "scroll-view", "标签上设置scroll-x为true，并且加上", "white-space:nowrap;", "就能实现横向滚动了。标签页用的是", "vant", "的", "tab标签页", "，就省下自己写原生标签页的功夫可以去写别的了，不过小白白可以有空手动写一个，不算很难的。", "\r\n", "\r\nwxml", "\r\n", "<!-- miniprogram/pages/ranking/ranking.wxml -->\r\n<view class=", "\"ranking\"", ">\r\n  <!-- 风云榜头部的分类 -->\r\n  <view class=", "\"ranking-header\"", ">\r\n    <!-- 滑动的部分 -->\r\n    <scroll-view class=", "\"header\"", " scroll-x=", "\"{{true}}\"", " scroll-left=", "\"{{scrollLeft}}\"", ">\r\n      <view wx:", "for", "=", "\"{{headerList}}\"", " wx:key=", "\"index\"", " class=", "\"headerList {{currentIndex === index?'selected': ''}}\"", " data-index=", "\"{{index}}\"", " bindtap=", "\"selected\"", ">\r\n        {{item}}\r\n      </view>\r\n    </scroll-view>\r\n    <!-- 箭头部分 -->\r\n    <view class=", "\"header-arrow\"", " bindtap=", "'showAllSort'", ">\r\n      <view class=", "\" {{isShow ? 'down-arrow up-arrow': 'down-arrow'}} \"", "></view>\r\n    </view>\r\n    <!-- 导航栏部分 -->\r\n    <view wx:", "if", "=", "\"{{isShow}}\"", " class=", "\"{{isShow ? 'header-sort opacity' : ''}}\"", ">\r\n      <van-transition name=", "\"fade-down\"", ">\r\n        <view wx:", "for", "=", "\"{{headerList}}\"", " wx:key=", "\"index\"", " class=", "'headerSort'", " data-index=", "\"{{index}}\"", " bindtap=", "\"selected\"", ">\r\n          {{item}}\r\n        </view>\r\n      </van-transition>\r\n    </view>\r\n  </view>\r\n  <!-- 下面的排行榜部分 -->\r\n  <view class=", "\"ranking-container\"", ">\r\n    <van-tabs active=", "\"{{ active }}\"", " animated>\r\n      <!-- 热度榜 -->\r\n      <van-tab title=", "\"热度榜\"", ">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=", "\"ranking-content\"", " wx:", "for", "=", "\"{{programs}}\"", " wx:key=", "\"{{index}}\"", ">\r\n          <view class=", "\"ranking-list\"", " data-set=", "\"{{item}}\"", " bindtap=", "\"navigate\"", ">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=", "\"list-left\"", ">\r\n              <image src=", "\"{{item.img}}\"", " mode=", "'aspectFill'", " class=", "'image'", " />\r\n              <view class=", "\"list-number\"", ">{{index + 1}}</view>\r\n              <view class=", "\"list-vip\"", " wx:", "if", "=", "\"{{item.vip}}\"", ">VIP</view>\r\n              <view class=", "\"list-count\"", ">{{item.count}}</view>\r\n            </view>\r\n            <view class=", "\"list-right\"", ">\r\n              <view class=", "\"list-title\"", ">{{item.title}}</view>\r\n              <view class=", "\"list-desc\"", ">{{item.desc}}</view>\r\n              <view class=", "\"list-hot\"", ">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n      <!-- 飙升榜 -->\r\n      <van-tab title=", "\"飙升榜\"", ">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=", "\"ranking-content\"", " wx:", "for", "=", "\"{{programs}}\"", " wx:key=", "\"{{index}}\"", ">\r\n          <view class=", "\"ranking-list\"", " data-set=", "\"{{item}}\"", " bindtap=", "\"navigate\"", ">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=", "\"list-left\"", ">\r\n              <image src=", "\"{{item.img}}\"", " mode=", "'aspectFill'", " class=", "'image'", " />\r\n              <view class=", "\"list-number\"", ">{{index + 1}}</view>\r\n              <view class=", "\"list-vip\"", " wx:", "if", "=", "\"{{item.vip}}\"", ">VIP</view>\r\n              <view class=", "\"list-count\"", ">{{item.count}}</view>\r\n            </view>\r\n            <view class=", "\"list-right\"", ">\r\n              <view class=", "\"list-title\"", ">{{item.title}}</view>\r\n              <view class=", "\"list-desc\"", ">{{item.desc}}</view>\r\n              <view class=", "\"list-hot\"", ">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n      <!-- 播放指数榜 -->\r\n      <van-tab title=", "\"播放指数榜\"", ">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=", "\"ranking-content\"", " wx:", "for", "=", "\"{{programs}}\"", " wx:key=", "\"{{index}}\"", ">\r\n          <view class=", "\"ranking-list\"", " data-set=", "\"{{item}}\"", " bindtap=", "\"navigate\"", ">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=", "\"list-left\"", ">\r\n              <image src=", "\"{{item.img}}\"", " mode=", "'aspectFill'", " class=", "'image'", " />\r\n              <view class=", "\"list-number\"", ">{{index + 1}}</view>\r\n              <view class=", "\"list-vip\"", " wx:", "if", "=", "\"{{item.vip}}\"", ">VIP</view>\r\n              <view class=", "\"list-count\"", ">{{item.count}}</view>\r\n            </view>\r\n            <view class=", "\"list-right\"", ">\r\n              <view class=", "\"list-title\"", ">{{item.title}}</view>\r\n              <view class=", "\"list-desc\"", ">{{item.desc}}</view>\r\n              <view class=", "\"list-hot\"", ">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n    </van-tabs>\r\n  </view>\r\n</view>\r\n", "复制代码", "wxss", "\r\n", "/* miniprogram/pages/ranking/ranking.wxss */\r\n.ranking {\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n}\r\n.ranking .ranking-header {\r\n  width: 100%;\r\n  height: 80rpx;\r\n  background-color: ", "#F6F6F6;", "\r\n  border-bottom: 2rpx solid ", "#E3E3E3;", "\r\n}\r\n.ranking .ranking-header .header {\r\n  width: 90%;\r\n  height: 100%;\r\n  white-space: nowrap;\r\n  overflow-x: auto;\r\n}\r\n/* .header::-webkit-scrollbar {\r\n  display: none;\r\n} */\r\n.ranking .ranking-header .header .headerList {\r\n  display: inline-block;\r\n  margin: 0rpx 25rpx;\r\n  text-align: center;\r\n  line-height: 80rpx;\r\n  \r\n}\r\n.ranking .ranking-header .header .headerList.selected {\r\n  color: green;\r\n}\r\n.ranking .ranking-header .header-arrow {\r\n  position: absolute;\r\n  right:0;\r\n  top:0;\r\n  overflow: hidden;\r\n  width: 80rpx;\r\n  height: 80rpx;\r\n  background-color: ", "#F6F6F6;", "\r\n  border-left: 1px solid ", "#E3E3E3", "\r\n}\r\n.ranking .ranking-header .header-arrow .down-arrow {\r\n  width: 25rpx;\r\n  height: 25rpx;\r\n  border-bottom: 2px solid ", "#999;", "\r\n  border-right: 2px solid ", "#999;", "\r\n  margin: 40rpx auto 0rpx;\r\n  transform: rotateZ(45deg) translate(-50%,-50%);\r\n  transition: transform 0.5s;\r\n}\r\n.ranking .ranking-header .header-arrow .down-arrow.up-arrow {\r\n  transform: rotateZ(-135deg) translate(25%,25%);\r\n}\r\n.ranking .ranking-header .header-sort {\r\n  width: 100%;\r\n  border-bottom: 1px solid ", "#EFEFEF;", "\r\n  background-color: rgba(255, 255, 255,0.8);\r\n  position: absolute;\r\n  z-index: 5;\r\n  transition: opacity 3s;\r\n}\r\n\r\n.ranking .ranking-header .header-sort .headerSort {\r\n  width: 20%;\r\n  display: inline-block;\r\n  font-size: 25rpx;\r\n  text-align: center;\r\n  margin: 17rpx auto;\r\n  opacity: 0.8;\r\n}\r\n.ranking .ranking-container {\r\n  width: 100%;\r\n}\r\n.ranking .ranking-container .ranking-content {\r\n  width: 100%;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list {\r\n  display: flex;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left {\r\n  display: inline-block;\r\n  margin: 20rpx;\r\n  position: relative;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .image {\r\n  width: 270rpx;\r\n  height: 150rpx;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-number {\r\n  position: absolute;\r\n  left: 0rpx;\r\n  top: 0rpx;\r\n  font-size: 35rpx;\r\n  background-color: ", "#FC2932;", "\r\n  width: 45rpx;\r\n  height: 45rpx;\r\n  padding-right: 10rpx;\r\n  text-align: center;\r\n  border-radius: 0 5rpx 45rpx 0;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-vip {\r\n  position: absolute;\r\n  top: 0rpx;\r\n  right: 5rpx;\r\n  font-size: 25rpx;\r\n  background-color: ", "#E1B876;", "\r\n  color: ", "#FFF;", "\r\n  padding: 0rpx 10rpx 5rpx;\r\n  border-radius: 0 0 10rpx 10rpx;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-count {\r\n  position: absolute;\r\n  right: 20rpx;\r\n  bottom: 20rpx;\r\n  font-size: 20rpx;\r\n  color: ", "#fff;", "\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right {\r\n  display: inline-block;\r\n  position: relative;\r\n  top: 15rpx;\r\n  padding: 10rpx;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n  overflow: hidden;\r\n  flex: 1;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-title {\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n  margin-bottom: 15rpx;\r\n  overflow:hidden;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-desc {\r\n  font-size: 30rpx;\r\n  margin-bottom: 20rpx;\r\n  color: ", "#999;", "\r\n  overflow: hidden;\r\n  text-overflow:ellipsis;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-hot {\r\n  font-size: 25rpx;\r\n  color: ", "#999", "\r\n}\r\n", "复制代码", "还有几个页面比较简单，就不介绍了。", "\r\n", "\r\n", "功能的实现", "\r\n", "高亮模糊查询", "\r\n", "\r\n", "这里我只是实现了一个简单版的模糊查询，也参考了一下网上的思路(好吧是我太菜了)，毕竟有问题就找度娘嘛。实时获取到输入框中的文字", "value", "，用", "filter", "和", "include", "方法筛选出包含", "value", "的名字，放入", "filter_list", "数组中,再遍历", "filter_list", "数组，将其中的字段切分为三段，然后就是这样的\r\n", "\r\n当", "value", "和其中的一项相等时，就改变颜色，怎么样，是不是还挺简单的", "\r\n", "onChange(event) {\r\n    const list = this.data.allName;//这里是所有的名字\r\n    const value = event.detail; //实时获取输入框中的文字\r\n    const result = [] \r\n    ", "if", " (event.detail !== ", "''", ") {//当输入框中有文字的话，就筛选出含有value的名字\r\n      ", "let", " filter_list = [...new Set(//用Set是因为我的数据中有重复的字段\r\n        list.filter(item => {\r\n          ", "return", " item.includes(value)\r\n        })\r\n      )]\r\n      filter_list.forEach(item => {//遍历\r\n      // 将名字切割成三段放入数组中，和value一样的字段的就换个颜色\r\n        ", "let", " index1 = item.indexOf(value)\r\n        ", "let", " index2 = value.length\r\n        ", "let", " string1 = item.slice(0, index1)\r\n        ", "let", " string2 = item.slice(index1, index1 + index2)\r\n        ", "let", " string3 = item.slice(index1 + index2)\r\n        console.log([string1, string2, string3])\r\n        result.push([string1,string2,string3])\r\n      })\r\n      this.setData({\r\n        value,\r\n        result\r\n      })\r\n    } ", "else", " {\r\n      this.setData({\r\n        result: null\r\n      })\r\n    }\r\n  },\r\n", "复制代码", "<!-- 这里是搜索到的结果 -->\r\n  <view class=", "\"results\"", ">\r\n    <view class=", "\"result\"", " wx:", "for", "=", "\"{{result}}\"", " wx:key=", "\"index\"", " bindtap=", "\"navigate\"", " data-name=", "'{{item}}'", ">\r\n      <text  wx:", "for", "=", "\"{{item}}\"", " class=", "\"{{item == value ? 'highlight' : 'normal' }}\"", " wx:key=", "\"index\"", ">{{item}}</text>  \r\n    </view>\r\n  </view>\r\n", "复制代码", "页面的带参跳转", "\r\n", "我给每个需要跳转的元素都绑定了设置了自定义属性", "data-*", "和用", "bind-tap", "绑定了", "navigate", "点击事件，方便在js中获取当前需要的信息,在跳转的时候用路由传参的形式将信息携带过去，", "JSON.stringify()", "方法可以将", "对象", "或者", "数组", "转换为一个 ", "JSON字符串", "\r\n", " navigate(e) {\r\n    const dataSet = e.currentTarget.dataset.set;\r\n    const item = JSON.stringify(dataSet);\r\n    wx.navigateTo({\r\n      url: ", "'../show/show?item='", " + item\r\n    })\r\n  },\r\n", "复制代码", "然后在接收的时候使用", "JSON.parse()", "方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作).就可以在该显示的界面获取到信息了", "\r\n", "onLoad: ", "function", " (options) {\r\n    const item = JSON.parse(options.item);\r\n    this.setData({\r\n      entities : item\r\n    })\r\n  },\r\n", "复制代码", "\r\n", "云数据库的增删改查", "\r\n", "这里大概是最让我崩溃的一个环节了，其中的辛酸苦辣(抹眼泪)，就是有句mmp不知当讲不当讲，同样的操作，上午不能执行成功，然后检查代码查bug翻文档，下午就能执行成功了，回头一看，我又没改代码，怎么就成功了呢，咋的，觉着我好欺负？\r\n", "\r\n", "添加数据和删除数据", "\r\n", "exports.main = async (event, context) => {\r\n  ", "if", "(event.isAdd) {//idAdd是传过来的参数，为", "true", "时，往wxlike集合中添加字段\r\n    ", "return", " db.collection(", "'wxlike'", ").add({\r\n      data: {\r\n        id: event.index,\r\n        Videoes:event.entity\r\n      }\r\n    })\r\n      .then(res => {\r\n        console.log(res)\r\n      })\r\n  } ", "else", " {//isAdd为", "false", "时，根据id查到这个字段，然后删除\r\n    ", "return", " db.collection(", "'wxlike'", ").where({\r\n      id: event.index\r\n    }).remove();\r\n  }\r\n}\r\n", "复制代码", "在iqiyi这个集合中根据name属性找到相应的字段并且获取id，再根据id去更新字段。", "\r\n", "exports.main = async (event, context) => {\r\n  ", "let", " entities = await db.collection(", "'iqiyi'", ").where({\r\n    name: event.name\r\n  })\r\n  .get();\r\n  ", "let", " id = entities._id;\r\n  ", "return", " await db.collection(", "'iqiyi'", ").doc(id).update({\r\n    data: {\r\n      hotspot: {\r\n        videoes:event.entities\r\n      }\r\n    }\r\n  }).then(res => {\r\n  })\r\n}\r\n", "复制代码", "根据传过来的name属性从集合中查找数据", "\r\n", "exports.main = async (event, context) => {\r\n  \r\n  ", "let", " entities = await db.collection(", "'iqiyi'", ").where({\r\n    name: event.name\r\n  })\r\n  .get()\r\n  ", "return", " entities\r\n}\r\n", "复制代码", "看，数据库增删查改就这么几行代码就能搞定，真是幸福感爆棚。", "\r\n", "只能同时播放一个的视频", "\r\n", "在热点页，视频都是以单个", "video", "的形式存在,", "\r\n", "<video src=", "\"{{ item.video}}\"", " duration=", "\"{{item.duration }}\"", " object-fit=", "\"cover\"", " id=", "\"{{ item.id}}\"", "  bindtap=", "\"handleVideoPlay\"", " data-vid=", "\"{{item.id}}\"", " ></video>\r\n", "复制代码", "emmmmmm,这一段好像上面看过了，没事那就在看一遍吧。\r\n我们需要控制它不能同时播放两个视频，点击下一个视频时，上一个视频需要暂停掉，不然同时两个视频的声音播放，我觉得脑壳可能会炸掉。我们给每个video标签都绑定", "handleVideoPlay", "方法，并且设置自定义属性", "data-vid=\"{{item.id}}\"", "方便来获取他们的", "id", "来分别控制和播放", "\r\n", "handleVideoPlay(e) {\r\n    ", "if", " (this.data.currentVideo) {//currentVideo是当前播放的视频，初始值为null\r\n      this.data.currentVideo.pause();//如果存在currentVideo则停掉\r\n    }\r\n    const Vid = e.target.id;//获取点击的视频的id\r\n    ", "if", " (Vid) {\r\n      // 创建 video 上下文 VideoContext 对象。\r\n      const currentVideo = wx.createVideoContext(`", "${Vid}", "`);\r\n      this.setData({\r\n        currentVideo\r\n      })\r\n      currentVideo.play();\r\n    }\r\n  },\r\n", "复制代码", "结语", "\r\n", "总体来看吧，这个demo主要是就是切页面，云数据库的操作和数据渲染了，呐呐呐，这是", "github地址", ",虽然页面和功能不多，在写的时候还是磕磕绊绊的遇到了各种各样的问题，不过最终还算是完成了。以后再接再厉鸭！！！最后祝看文章的小姐姐都能有杨紫小猴子辣么漂酿，，小哥哥都比李现现还帅，单身的程序猿都能找到像佟年和韩商言一般的好对象，蟹蟹蟹蟹啦，，留下个赞再走叭！！！", " "]}
{"title": "小程序跨平台开发解决方案探索 ", "author": "Rolan", "pub_time": "2019-8-2 00:15", "content": [" \n                     \n                    ", "原文地址： ", "ant-move.github.io/website/blo…", "继微信正式推出微信", "小程序", "后，各个大厂陆续发布了各自的小程序平台 —— 支付宝小程序、百度小程序、头条小程序，跨小程序平台开发也成为了众多小程序开发者要面临的问题。", "Antmove - 小程序跨平台解决方案", "小程序开发血泪史", "小程序发展初期", "框架不稳定", "更新频繁", "bug 众多", "随着微信小程序的发展，微信小程序以基本不存在上述的问题，而其它新兴的小程序厂商则还在此阶段，对于小程序开发者来说，如果要接入微信小程序之外的平台，以上的问题是技术方案评估环境必须要衡量的问题。", "小程序发展中期", "开发体验提升", "组件式开发需求", "与 web 开发技术生态的融合", "在这个阶段，小程序开发者追求的是开发体验，在 web 框架蓬勃发展，开发工具生态飞速完善的环境下，槽糕的小程序开发体验是用户不能忍受的，这个阶段也出现了许多的小程序框架极力的解决这个问题，如 wepy、mpvue、taro 等。", "小程序发展成熟期", "多平台支持需求", "包体积", "性能", "到今年以来，除微信小程序平台外，其它厂商小程序平台也得到了极大的推动发展，这时小程序跨平台能力就显得尤为重要，同时与之相对的包体积控制小程序性能也成为关注点，这也是目前众多企业和开发者面临的问题。", "小程序跨平台开发解决方案探索", "小程序跨平台开发，简单来说就是通过一套解决方案实现开发一次，上线到多个小程序平台。", "解决方案", "为满足多小程序平台的需求，简单来说可以有以下的解决方案：", "各平台单独开发", "人力成本高", "开发某一个平台小程序，通过技术实现到其它平台的转换", "技术实现成本高，小团队难以支撑", "使用支持跨平台的小程序框架开发，依赖于框架的跨平台能力，实现跨平台", "引入框架成本", "对于第三种方案来说，目前社区中比较热门的小程序跨平台开发解决方案有 mpvue、taro、uni-app 等。这些框架不同程度的解决了小程序跨平台开发的问题，但他们都存在一个饱受诟病的问题，那就是框架之痛。在前端开发的发展过程中，从前端框架出现到百花争鸣，到现在的三足鼎立（Angular、React、Vue）时代，开发者依然会因如下的 问题而头疼：", "是否应该在项目中引入框架？", "应该选择什么样的框架，更好？更适合？", "在性能面前，应该选择框架还是采用原生开发？", "团队开发技术栈统一之争？", "老项目维护问题，技术升级之痛？", "该框架的未来发展是怎样的？", "作为小程序的开发者，依然会面临这样的问题，而且会更加严重， 小程序本身就是一个框架（而且小程序框架发展很快，功能也在不断完善，开发体验也越来越好） ，在小程序之上又包一层框架，整个开发流程多了一环，无疑会增加项目的风险。而且小程序框架本身还在不断的发展，以微信小程序为例，新特性、能力、规范不断的更新，框架如何短时间的更新适配就成为一个难题。而依赖框架之后，开发者与原生小程序隔离开来，不得不依赖框架方提供解决方案。", "除了框架能力的支持适配，引入框架还会使得项目本身变得臃肿、缓慢、约束。", "解决方案之 Antmove", "在高德小程序开发团队（阿里系小程序的一员【支付宝小程序、淘宝应用、钉钉应用、天猫精灵等】）的工作中，我们遇到了许多想将微信小程序应用上线到阿里系小程序平台的客户，而重新开发一个新平台的小程序对他们来说又比较耗成本，为了解决这个问题，蚂蚁搬家工具应运而生，我们的出发点很简单，希望能够通过技术手段将一个微信小程序应用上线到阿里系小程序平台上。", "随着这个过程的进行，我们发现用户除了有对阿里系平台的需求外，还有对其它小程序平台支持的需求，所以又有了其它厂商小程序平台的支持。", "多小程序平台支持", "目前百度智能小程序、头条小程序的支持还在内测，即将可以体验。", "从最初的客户服务案例到现在的 antmove 开源项目，我们整个团队考虑过很多，作为一个非 KPI 项目，我们会持续的将它做好，希望能帮助更多的小程序开发者解决他们遇到的问题。", "Antmove 不是一个框架，而是一个转换工具，比如将微信小程序项目转换为支付宝小程序项目，它更多的还是希望开发者能使用原生的小程序语法去开发小程序，更小、更快、更简洁。", "到目前为止，Antmove 工具已经帮助了众多的内部用户和外部小程序开发者实现小程序的转换迁徙，现在也希望它能够帮助你解决跨平台开发的难题。", " "]}
{"title": "小程序Request的另类用法 ", "author": "Rolan", "pub_time": "2019-8-2 00:18", "content": [" \n                     \n                    ", "小程序", "中唯一能发送网络请求接口数据的是wx.request接口，当然这个接口存在诸多的限制，例如：10个并发请求限制，https限制（当然在开发阶段是可以关闭此限制），除了wx.request还有其他方法可以实现类型的功能吗？当然是有的,这个思路也源于我之前看到的一篇文章，随便笔记下来", "\r\n", "思路", "\r\n", "使用云开发来发送网络请求并把数据返回给小程序端。还不了解的云开发的同学请速度移步到官方【", "云开发", "】", "\r\n", "新建一个http的云函数", "\r\n", "// 云函数入口文件", "\r\n", "const", " cloud = ", "require", "(", "'wx-server-sdk'", ")\r\n", "const", " axios = ", "require", "(", "'axios'", ")\r\ncloud.init()\r\n\r\n", "// 云函数入口函数", "\r\nexports.main = ", "async", " (event, context) => {\r\n  ", "const", " wxContext = cloud.getWXContext()\r\n  ", "const", " { method, url, data } = event;\r\n  ", "const", " res = ", "await", " axios.request({\r\n    ", "method", ": method,\r\n    ", "url", ": url,\r\n    ", "data", ": data\r\n  });\r\n\r\n  ", "return", " { ", "code", ": ", "1", ", ", "data", ": res.data } || {", "code", ": ", "-1", ", ", "msg", ": ", "'error'", ", ", "data", ": ", "null", "}\r\n}\r\n", "复制代码", "小程序端二次封装云函数调用", "\r\n", "async", " http(options = {}) {\r\n\t", "return", " wx.cloud.callFunction({\r\n\t\t", "name", ": ", "'http'", ",\r\n\t\t", "data", ": {\r\n\t\t\t", "method", ": options.method || ", "'GET'", ",\r\n\t\t\t", "url", ": options.url || ", "''", ",\r\n\t\t\t", "data", ": options.data || {}\r\n\t\t}\r\n\t}).then(", "res", " =>", " {\r\n\t\t", "return", " res.result\r\n\t})\r\n},\r\n", "复制代码", "小程序端使用", "\r\n", "async", " onLoad() {\r\n    ", "this", ".http({\r\n      ", "method", ": ", "'GET'", ",\r\n      ", "url", ": ", "'https://www.baidu.com'", "\r\n    }).then(", "res", " =>", " {\r\n      ", "console", ".log(res)\r\n    })\r\n  },\r\n", "复制代码", "总结", "\r\n", "这种方法可以很好绕过https的限制，当然这只是提供一个简单的思路，我们可以进一步细一点封装，包括配置header proxy 等等功能，其实原理就是借助云函数做了二次转发，性能上肯定比不上原生的request", "\r\n", "注意", "\r\n", "async 和 await 语法糖在最新的开发工具中已经实现了，开启增强编译即可使用，具体更新内容请移步官方社区 ", "微信小程序社区", " "]}
{"title": "随手开源一个微信小程序仪表盘组件 ", "author": "Rolan", "pub_time": "2019-7-23 00:23", "content": [" \n                     \n                    ", "最近在一个", "小程序", "项目中做了个动态仪表盘效果，感觉有点复用价值，就顺便给组件化了，丰富了几个常用配置，绘制元素根据尺寸自适应，差不多具备了一个自定义组件的基本素质。", "开发非常简单没有值得说的点，开发之外却是一步一个坑。", "先来预览下效果：", "感兴趣的直接看源码：", "https://github.com/tower1229/weapp-plugin-dashboard", "下面是踩坑过程。", "如何开发微信小程序自定义组件", "官方提供了一个CLI工具专门用于开发小程序自定义组件，首先全局安装这个工具：", "npm", " ", "install", " ", "-g", " @", "wechat", "-", "miniprogram", "/", "miniprogram", "-", "cli", "\r\n", "然后用它初始化一个自定义组件项目：", "miniprogram init --", "type", " ", "custom", "-", "component", "\r\n", "这一步会下载一个前端工程模板到本地，这个模板是一个基于gulp的前端自动化工程，使用前需要先安装依赖：", "npm", " i\r\n", "有可能你会像我一样发现这个项目的默认依赖版本有点老，然后习惯性的在VSCode里用 ", "Npm Dependency", " 自动升级了一下，重新安装，然后就傻逼了，新版babel插件会让项目跑不起来。", "还原到默认版本重新安装，启动开发服务：", "npm ", "run", " watch\r\n", "这时自动化工程会将 ", "src/", " 里的代码构建到 ", "miniprogram_dev/", " 文件夹，这里面是一个标准的小程序目录结构，是可以用微信开发者工具导入并运行的，导入的时候注意使用测试appId。", "然后这边我们编辑src里的源码文件，另一边就会同步构建到miniprogram_dev，微信开发者工具检测到文件变动也会自动重新编译项目，目前为止很美好。", "但就我的亲身体验来看，这个自动化工程有点小毛病，偶尔会把个别文件给编译“丢”，比如突然样式没了，或者js编译不通过，那么js文件也就没了，微信开发者工具这边就会报错。", "最坑的是，这个工程的编译过程集成了eslint代码检查，检查不通过js文件就不编译，任由开发者工具报错。默认的eslint配置是有多变态？起码对我来说这是个很难忘的经历，一下午都在咬牙切齿的查各种eslint报错是什么意思，怎么关掉。", "不过eslint也有一些有意义的要求，比如 ", "parseInt()", " 方法的第二个参数通常我都不传，严格来说这样确实不算好的实践。", "canvas在小程序组件中的使用", "开发过程中遇到最坑的问题，是我自己看文档不仔细导致的，但我觉得更大的责任在于小程序官方文档太乱了。", "初始化canvas实例的 ", "wx.createCanvasContext()", " 方法，其实有两个参数，第二个参数通常也是都不传，仅在组件内使用时这个参数才需要传 ", "this", " ，之前一直没在组件里用过canvas，导致忘了还有这么个参数，也不报错，就是canvas死活画不出东西，查了好半天才发现是这个原因。", "这种情况完全可以在开发工具中给个报错，为什么不？", "查文档的过程中，真心觉得小程序的文档组织太TM乱了，知识点是全的，但同一个东西的知识点散落的到处都是，比如说单独看【框架】这个栏目的内容，你根本不可能掌握小程序框架是怎么一回事，再看看“指南”才能知道个大概，然后再看组件和API，才能写出个hello world项目。", "就说自定义组件的开发吧，自定义组件的接口、开发、发布、安装每个环节的内容，被分别散落在【框架】、【指南】、【工具】的不同篇幅里，也就是第一次开发自定义组件的时候，需要把整个文档都翻腾一遍，才能找到所有我需要知道的东西，你说扯不扯。", "发布与安装npm包", "自定义组件开发完了就要发布到npm，发布过程是全程最愉快的部分了，一点坑没有，开发环境测试没问题，运行构建命令：", "npm ", "run", " build\r\n", "这时会产出一个 ", "miniprogram_dist/", " 文件夹，整个项目的 ", ".gitignore", " 和 ", ".npmignore", " 都预置好了，如果你把代码提交到GitHub，将只提交源码和必要的工程文件；如果要发布到npm，在已经登录npm的前提下只要执行：", "npm", " publish\r\n", "就会按小程序支持的格式（包含 ", "miniprogram_dist/", " ）将代码发布到npm，然后就可以在其他小程序项目里安装并使用了。", "小程序项目安装npm包有点麻烦。", "首先在小程序代码根目录（project.config.json中miniprogramRoot配置的目录）中依次执行：", "npm ", "init", "\r\nnpm i weapp-plugin-dashboard -", "S", " --production    ", "// 此处以安装weapp-plugin-dashboard模块为例", "\r\n", "只有这样安装的模块才算数，一开始我随手创建了个 ", "package.json", " 文件写上依赖包名称，然后执行 ", "npm i", " ，虽然模块也下载了，但会在下一步的开发者工具中报错，提示找不到npm包，可能是因为 ", "package.json", " 文件不规范，但是文档没有告知怎样的 ", "package.json", " 才算规范。", "安装完毕后，在开发者工具中看不到 ", "node_modules/", " 这个目录，因为此时这些模块小程序还并不支持，需要再构建一下才能用。", "首先，在开发者工具的项目配置里开启 ", "使用npm模块", " ，然后执行“工具-构建npm”操作，成功后会产出一个 ", "miniprogram_npm/", " 文件夹，这个文件夹是可以在开发者工具中看到的，到这一步npm包才算真的安装成功，可以在小程序项目中正常调用了。", "结语", "再放一遍项目地址吧，注意项目里的代码是开发工程的代码，需要运行构建命令（ ", "npm run build", " ）才能得到小程序组件代码。想在项目里使用组件也可以直接npm安装 ", "weapp-plugin-dashboard", " ，具体步骤前面说过了。", "Github： ", "https://github.com/tower1229/weapp-plugin-dashboard", "再说点小程序开发的话题。", "截至目前，小程序开发相关的讨论，热门话题基本都是围绕那些“一次开发，处处运行”的轮子，什么taro啊uni-app啊，这些东西在我看来跟“生态”不沾边，起码在目前这个大局未定的阶段，可以说除了炫技毫无意义，任何对团队负责的架构师都不应该选择这种技术栈。", "我理解的生态，比如三方组件库，在小程序这几乎是市场空白；只面向企业开放的小程序插件，也没见到个正经推广的；杀手级应用也很少，大部分都是昙花一现，或者游戏类的；总体感觉就是，小程序开发没有热度，新手都在学，主力都在观望。", "这可能是因为小程序还没有找到合理的变现模式，如果任何一个企业如果能率先通过小程序打通一个商业模式，那么至少能带动同行业的所有企业复制这种模式，这样开发者的开发场景就会高度集中，大家面临的问题都很相似，才有可能产生流行的三方组件，进而促成生态繁荣。", "问题是，曾经的那些“变现模式”都迅速被微信封杀了，那么微信自己到底怎么定义小程序呢？小程序显然不是一个像HTML5那样的“通用媒介”，很多事情在小程序上不能做，而且这个不能做的范围，与其说是技术限制，倒不如说是人为的“政策限制”，而且这个政策非常之模糊和不确定。", "涉及到流量的不行，涉及到腾讯竞品行业的不行，涉及到钱的，我觉得就算让我做我也不敢做，因为今天可以的，明天可能就不可以了，生杀大权全在微信一句话，或者连句话都没有。", "就是说微信不准备让小程序成为一个公益性质的第三方平台，而是希望小程序只为微信服务，让符合微信利益的服务商以微信喜欢的方式接入，然后以小程序的形式替代对应的原生APP，从而完成对一整个“生态位”的吞噬，到那时恐怕连操作系统都要面向“微信”开发了。", "照这个思路，个人开发者对微信来说，可能只是免费的外部测试团队吧。", " "]}
{"title": "【小程序 + 云开发】体重记录小程序 上手笔记 ", "author": "Rolan", "pub_time": "2019-7-23 00:25", "content": [" \n                     \n                    ", "刚刚提交的", "小程序", "审核通过了，把笔记发出来。\r\n前一段看到朋友圈里总是有人用txt记录体重，就特别想写一个记录体重的小程序，\r\n现在小程序的云开发有云函数、数据库，真的挺好用，很适合个人开发者，服务器域名什么都不用管，云开发让你完全不用操心这些东西。", "\r\n", "先看看页面效果图吧：", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n记录的几个点：", "\r\n", "\r\n", "全局变量 globalData", "\r\n", "npm 的使用", "\r\n", "云函数", "\r\n", "数据库操作", "\r\n", "async 的使用", "\r\n", "分享的配置", "\r\n", "antV使用", "\r\n", "tabBar地址跳转", "\r\n", "切换页面刷新", "\r\n", "\r\n", "1.全局变量 globalData", "\r\n", "首次进入后，要存储openId给其他页面使用，使用globalData共享。", "\r\n", "<!--app.js 设置 globalData.openid --> \r\nApp({\r\n  ", "onLaunch", ": ", "function", " (", ") ", "{\r\n\r\n    ", "this", ".globalData = {}\r\n\r\n    wx.cloud.init({})\r\n\r\n    wx.cloud.callFunction({\r\n      ", "name", ": ", "'login'", ",\r\n      ", "data", ": {},\r\n      ", "success", ": ", "res", " =>", " {\r\n        ", "this", ".globalData.openid = res.result.openid\r\n        wx.switchTab({\r\n          ", "url", ": ", "'/pages/add/add'", ",\r\n          ", "fail", ": ", "function", "(", "e", ") ", "{}\r\n        })\r\n      }, \r\n      ", "fail", ": ", "err", " =>", " { \r\n     \r\n      }\r\n    })\r\n\r\n  }\r\n})\r\n\r\n<!--其他页面引用-->\r\n", "const", " app = getApp()  ", "// 获得实例", "\r\napp.globalData.openid ", "// 直接引用即可", "\r\n", "复制代码", "2.npm 的使用", "\r\n", "\r\n", "进入小程序源码", "miniprogram", "目录，创建", "package.json", "文件（使用", "npm init", "一路回车）", "\r\n", "npm i --save", " 我们要安装的", "npm", "包", "\r\n", "设置微信开发者工具 构建", "npm", "\r\n", "package.json", "增加", "\"miniprogram\": \"dist\"", "打包目录字段，如果不设置的话上传和预览不成功，提示文件包过大。", "\r\n", "\r\n", "cd", " miniprogram\r\nnpm init \r\nnpm i @antv/f2-canvas --save   // 我用到了f2，可以换成其他包\r\n", "复制代码", "设置微信开发者工具", "\r\n", "\r\n构建", "npm", "\r\n", "\r\n", "最后，务必添加", "miniprogram", "字段", "\r\n", "{\r\n  ", "\"name\"", ": ", "\"21Day\"", ",\r\n  ", "\"version\"", ": ", "\"1.1.0\"", ",\r\n  ", "\"miniprogram\"", ": ", "\"dist\"", ",\r\n  ", "\"description\"", ": ", "\"一个21天体重记录的app\"", ",\r\n  ", "\"license\"", ": ", "\"MIT\"", ",\r\n  ", "\"dependencies\"", ": {\r\n    ", "\"@antv/f2-canvas\"", ": ", "\"~1.0.5\"", ",\r\n    ", "\"@antv/wx-f2\"", ": ", "\"~1.1.4\"", "\r\n  },\r\n  ", "\"devDependencies\"", ": {}\r\n}\r\n", "复制代码", "3.云函数", "\r\n", "官方解释", "云函数即在云端（服务器端）运行的函数", "，服务端是", "node.js", "，都是", "JavaScript", "。官方有数据库的操作，但是", "更新的操作强制要求使用云函数", ",\r\n另外，如果云函数中使用了", "npm", "包，记得在所在云函数文件夹右键", "上传并部署", "，不然运行失败。", "\r\n", "\r\n", "上一个例子，更新体重的云函数", "\r\n", "// 云函数", "\r\n", "const", " cloud = ", "require", "(", "'wx-server-sdk'", ")\r\n", "const", " moment = ", "require", "(", "'moment'", ")\r\n\r\ncloud.init(\r\n  { ", "traceUser", ": ", "true", " }\r\n)\r\n\r\n", "const", " db = cloud.database()\r\n", "const", " wxContext = cloud.getWXContext()\r\n\r\nexports.main = ", "async", " (event, context) => {\r\n  ", "// event 入参参数", "\r\n  ", "delete", " event.userInfo\r\n  ", "try", " {\r\n    ", "return", " ", "await", " db.collection(", "'list'", ").where({\r\n      ", "_openid", ":wxContext.OPENID,\r\n      ", "date", ":moment().format(", "'YYYY-MM-DD'", ")\r\n    })\r\n    .update({\r\n      ", "data", ": {\r\n      \t...event\r\n      },\r\n    })\r\n  } ", "catch", "(e) {\r\n    ", "console", ".error(e)\r\n  }\r\n}\r\n", "复制代码", "小程序端调用", "\r\n", "wx.cloud.callFunction({\r\n     ", "name", ": ", "'add'", ",\r\n     ", "data", ": {\r\n      ...Param\r\n     },\r\n     ", "success", ": ", "res", " =>", " {\r\n        wx.showToast({\r\n          ", "title", ": ", "'新增记录成功'", ",\r\n        })\r\n     },\r\n     ", "fail", ": ", "err", " =>", " { \r\n        wx.showToast({\r\n          ", "icon", ": ", "'none'", ",\r\n          ", "title", ": ", "'新增记录失败'", "\r\n        })\r\n     }\r\n   })\r\n", "复制代码", "4.数据库操作", "\r\n", "其实是接入的", "MongoDB", "，封装了一部分", "api", "出来，详细的就看", "官方文档", "把，有区分服务端和小程序段。", "\r\n", "const", " db = wx.cloud.database()\r\n\r\n", "// 查询数据", "\r\ndb.collection(", "'list'", ").where({\r\n    ", "_openid", ": app.globalData.openid,\r\n    ", "date", ": moment().subtract(", "1", ", ", "'days'", ").format(", "'YYYY-MM-DD'", "),\r\n}).get({\r\n    ", "success", ": ", "function", " (", "res", ") ", "{\r\n        ", "// do someThing", "\r\n    }\r\n})\r\n", "复制代码", "5.async 的使用", "\r\n", "\r\n官方文档提示不支持", "async", "，需要引入", "regeneratorRuntime", "这个包，先", "npm i regenerator", "。\r\n然后把", "node_modules", "文件夹下的", "regenerator-runtime", "的", "runtime-module.js", "和", "runtime.js", "两个文件拷贝到", "lib", "目录下，在页面上引入即可。", "\r\n", "<!--事例-->\r\n", "const", " regeneratorRuntime = ", "require", "(", "'../../lib/runtime.js'", ")\r\nonLoad: ", "async", " ", "function", " (", "options", ") ", "{\r\n\r\n    ", "// 获取当天数据", "\r\n    ", "await", " ", "this", ".step1()\r\n\r\n    ", "// 时间类型设置", "\r\n    ", "let", " nowHour = moment().hour(),timeType\r\n    nowHour > ", "12", " ? timeType = ", "'evening'", " : timeType = ", "'morning'", "\r\n    ", "this", ".setData({timeType})\r\n  }\r\n", "复制代码", "6.分享的配置", "\r\n", "分享很简单，有区分右上角的直接分享和点击按钮分享", "\r\n", "onShareAppMessage: ", "function", " (", "res", ") ", "{\r\n        \r\n      ", "// 右上角分享", "\r\n      ", "let", " ShareOption = {\r\n        ", "title", ": ", "'21天体重减肥记录'", ",\r\n        ", "path", ": ", "'/pages/index/index'", ",\r\n      } \r\n      \r\n      ", "// 按钮分享", "\r\n      ", "if", "(res.from == ", "\"button\"", "){\r\n        ShareOption = {\r\n            ", "title", ": ", "'来呀 看看我的减肥记录呀'", ",\r\n            ", "path", ": ", "'/pages/detail/detail?item='", " + app.globalData.openid,\r\n          } \r\n      }\r\n      \r\n      ", "return", " ShareOption\r\n  }\r\n", "复制代码", "分享后，他人点击页面，跳转到对应", "pages", "地址，从", "onLoad", "的", "options", "中拿入参请求数即可", "\r\n", "onLoad: ", "function", " (", "options", ") ", "{\r\n    ", "const", " db = wx.cloud.database()\r\n    ", "let", " This = ", "this", "\r\n    ", "let", " resault = {}\r\n    db.collection(", "'list'", ").where({\r\n      ", "_openid", ": options.item\r\n    }).get({\r\n      ", "success", ": ", "function", " (", "res", ") ", "{\r\n        resault = res.data\r\n        This.setData({\r\n          ", "resault", ":resault\r\n        })\r\n\r\n      }\r\n    })\r\n  },\r\n", "复制代码", "7.antV使用", "\r\n", "上边第二小节有提到", "antV", "的安装，就不再赘述，直接说一下再页面中引用。", "\r\n", "说下使用，需要设置一个全局变量储存图表的实例，然后在钩子函数内容使用", "changeData", "方法修改数据。", "\r\n", "index.json", "中引入包名", "\r\n", "{\r\n  ", "\"usingComponents\"", ": {\r\n  \t", "\"ff-canvas\"", ": ", "\"@antv/f2-canvas\"", "\r\n  }\r\n}\r\n", "复制代码", "// 引入F2", "\r\n", "import", " F2 ", "from", " ", "'@antv/wx-f2'", ";\r\n\r\n", "// 设置实例全局变量（务必）", "\r\n", "let", " chart = ", "null", ";\r\n", "function", " ", "initChart", "(", "canvas, width, height, F2", ") ", "{ ", "// 使用 F2 绘制图表", "\r\n  ", "let", " data = [\r\n    ", "// { timestamp: '1951 年', step: 38 },", "\r\n  ];\r\n\r\n  chart = ", "new", " F2.Chart({\r\n    ", "el", ": canvas,\r\n    width,\r\n    height\r\n  });\r\n\r\n  chart.source(data, {\r\n    ", "step", ": {\r\n      ", "tickCount", ": ", "5", "\r\n    },\r\n    ", "timestamp", ": {\r\n      ", "tickCount", ": ", "8", "\r\n    },\r\n\r\n  });\r\n\r\n\r\n  chart.axis(", "'timestamp'", ", {\r\n    label(text, index, total) {\r\n      ", "const", " textCfg = {};\r\n      ", "if", " (index === ", "0", ") {\r\n        textCfg.textAlign = ", "'left'", ";\r\n      }\r\n      ", "if", " (index === total - ", "1", ") {\r\n        textCfg.textAlign = ", "'right'", ";\r\n      }\r\n      ", "return", " textCfg;\r\n    }\r\n  });\r\n\r\n  chart.axis(", "'step'", ", {\r\n    label(text) {\r\n      ", "return", " {\r\n        ", "text", ": text / ", "1000", " + ", "'k步'", "\r\n      };\r\n    }\r\n  });\r\n\r\n  chart.tooltip({\r\n    ", "showItemMarker", ": ", "false", ",\r\n    onShow(ev) {\r\n      ", "const", " { items } = ev;\r\n      items[", "0", "].name = ", "null", ";\r\n      items[", "0", "].name = items[", "0", "].title;\r\n      items[", "0", "].value = items[", "0", "].value + ", "'步'", ";\r\n    }\r\n  });\r\n  chart.area().position(", "'timestamp*step'", ").shape(", "'smooth'", ").color(", "'l(0) 0:#F2C587 0.5:#ED7973 1:#8659AF'", ");\r\n  chart.line().position(", "'timestamp*step'", ").shape(", "'smooth'", ").color(", "'l(0) 0:#F2C587 0.5:#ED7973 1:#8659AF'", ");\r\n  chart.render();\r\n  ", "return", " chart;\r\n}\r\n\r\n", "// 生命周期函数", "\r\nonLoad(){\r\n    ", "// 使用changeData赋值", "\r\n    chart.changeData(stepInfoList)\r\n}\r\n", "复制代码", "8.tabBar地址跳转", "\r\n", "如果要跳转的地址不在", "app.json", "的", "tabBar", "内可以使用", "wx.navigateTo", "，如果在死活跳不过去，要使用", "wx.switchTab", "方法跳转。", "\r\n", "wx.switchTab({\r\n  ", "url", ": ", "'/pages/add/add'", ",\r\n  ", "fail", ": ", "function", "(", "e", ") ", "{}\r\n})\r\n\r\nwx.navigateTo({\r\n  ", "url", ": ", "'../deployFunctions/deployFunctions'", ",\r\n})\r\n", "复制代码", "9.切换页面刷新", "\r\n", "切换几个tabBar的时候，需要刷新数据。\r\n在", "onShow", "方法中再调用一下", "onLoad", "方法就可以了。", "\r\n", "onShow: ", "function", " (", ") ", "{\r\n    ", "this", ".onLoad()\r\n}\r\n", "复制代码", "感受", "\r\n", "\r\n", "很适合个人开发者，想开发一个小程序，除了时间，完全没有其他费用", "\r\n", "报错提示不友好，有时候不执行不报错，只能一行一行", "debug", "。", "\r\n", "审核超快，几个小时就审核通过了。", "\r\n", "lodash不支持，据说要修改点东西，就没鼓捣。", "\r\n", "git也配置上了，真的是方便，再感叹一下，不过语法真的是。。。。不想用。", "\r\n", "\r\n", "后记", "\r\n", "不知道自己能更几个版本，不过跟着练习呗，空了就更新。\r\n立个flag，写下list 哈哈。", "\r\n", "\r\n", "v1.0\r\n", "\r\n", "挑战邀请页", "\r\n", "\r\n", "\r\n", "v2.0\r\n", "\r\n", "每日一句减肥知识", "\r\n", "社交奖励", "\r\n", "签到后鼓励语句", "\r\n", "朋友圈图片分享", "\r\n", "\r\n", "\r\n", "v3.0\r\n", "\r\n", "排行榜", "\r\n", "好习惯发表", "\r\n", "等级区分", "\r\n", "\r\n", "\r\n", "\r\n", "码字码到手酸，为自己加油。", " "]}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": [" \n                     \n                    ", "编辑名片有两条路径，分为新增名片流程与修改名片流程。", "用户手填新增名片流程：", "首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。", "新增名片页面 1 基本布局如下：", "取到 userId。", "使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。", "也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。", "这里绑定了自带的模态框提示组件。", "其中 modalHidden2 是模态框开关。", "另外 proptText 是需要提示的内容。", "即使很多输入框也支持数据动态改变，非常方便。", "实际效果，非常快捷，比以前省去很多事情，编写", "小程序", "，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。", "最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。", "设置的直接是背景图片。", "提交表单与跳转。", "提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。", "这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。", "同样也是一些数据绑定以及验证效果。", "实际渲染效果可以看到。", "这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。", "修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：", "名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：", "姓名手机必填模块：", "个人信息模块，直接循环（block）出来：", "Onload 时我们请求必填与选填数据：", "* requiredGroup 必填中文信息", "* notRequiredGroup 选题中文信息", "* requiredGroupEn 必填英文信息", "* notRequiredGroupEn 选题英文信息", "```", "//请求名片对应的公司的中文信息的属性组数据，分为必填和选填", "//选题项变量以 no 开头", "requester.getOfflineCardInfoGroupFields(userId, cardId,", "function (res) {", "//debugger", "var userName = res.card.userName;", "var mobile = res.card.mobile;", "var requiredGroup = res.requiredGroupCh;", "var notRequiredGroup = res.notRequiredGroupCh;", "var requiredGroupEn = res.requiredGroupEn;", "var notRequiredGroupEn = res.notRequiredGroupEn;", "var reqLen = requiredGroup.fields.length;", "var nreqLen = notRequiredGroup.fields.length;", "var reqLenEn = requiredGroupEn.fields.length;", "var nreqLenEn = notRequiredGroupEn.fields.length;", "self.setData({", "userName: userName,", "mobile: mobile,", "requireFields: requiredGroup.fields,", "notRequireFields: notRequiredGroup.fields,", "requireFieldsEn: requiredGroupEn.fields,", "notRequireFieldsEn: notRequiredGroupEn.fields,", "l1: reqLen,", "l2: nreqLen + reqLen,", "l3: reqLenEn + nreqLen + reqLen", "});", "self.forceUpdate();", "}, function (code, msg) {", "console.info(\"code=\" + code + \"&msg=\" + msg);", "});", "```", "中英文信息必填与选填渲染：", "这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。", "今天再回去理下首页 A、B、C 定点跳转功能实现方法。", "首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：", "数据 sort，和 group.name 数据一样：", "这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。", "点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。", "首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。", "可以看下：", "这个 group.name==sortmsg，等于就是 A==A,B==B 同理。", "在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。", "跳转功能基本实现（ohter 就是 # 底部）。", " "]}
{"title": "小程序的一些小知识总结 ", "author": "Rolan", "pub_time": "2019-5-9 00:51", "content": [" \n                     \n                    ", "小程序", "很多方法都是异步的原因", "刚接触小程序的时候，发现很多微信提供的api都是异步的，如路由跳转，设置和读取缓存，还有获取节点信息等微信的api，都是异步的，需要传入回调函数才能获得结果，在我们正常的前端开发中，这些都不是异步的，当时很奇怪为什么是这样的，最近看了微信的一个开发教程之后，总算是明白了。 ", "微信小程序开发教程", "小程序的底层架构是双线程模式，逻辑层和渲染层是分开的两个线程，渲染层指的就是渲染wxml和wxss，逻辑层指的是执行js文件，两个线程分开运行，通过微信客户端进行通信，调用微信的api的时候其实就是执行js的线程和微信客户端通信", "下图是微信官方文档里渲染页面的一个流程图", "注意事项：", "上述说了，小程序的渲染层和逻辑层是分开的两个线程，执行js逻辑的只有一个线程，所以在js里声明了的函数，只要有调用，就算页面卸载了，最终都会执行，所以要注意的是，一些interval，或者一些注册的其他函数，如果不想在页面离开后继续执行的话，在页面卸载的时候要注销掉。", "发布和订阅模式", "先补充一个知识点：在小程序的appjs的onLaunch里，给全局变量wx添加的属性，是全局有效的，能在其他页面中调用，比如：", "onLaunch: ", "function", " (", ") ", "{\r\n    wx.aaa = ", "'123456'", "; \r\n    wx.bbb = ", "function", " (", ") ", "{ ", "console", ".log(", "'541521'", ") }\r\n}\r\n\r\n\r\nonLoad: ", "function", " (", ") ", "{\r\n    ", "console", ".log(wx.aaa);\r\n    wx.bbb();\r\n}", "之前对发布和订阅一直没什么概念，但是多学点东西总没坏处，近期自己花了点时间专门看了一下，大概明白了一点。", "订阅：订阅就是在某个地方注册一个自定义的事件，供其他地方调用", "发布：触发已经订阅的函数", "下面是我写的一个方法，可能会有一些bug，但是目前没有发现，要是有问题的话欢迎交流一下", "var", " MyEvent = (", "function", " (", ") ", "{\r\n  ", "// 声明方法", "\r\n  ", "var", " pub, sub, remove;\r\n\r\n  ", "// 订阅缓存记录", "\r\n  ", "var", " subCache = {};\r\n  ", "// 发布缓存记录", "\r\n  ", "var", " pubCache = {};\r\n  ", "// 参数缓存", "\r\n  ", "var", " paramCache = {};\r\n\r\n  ", "// 订阅事件", "\r\n  sub = ", "function", " (", "key, fn", ") ", "{\r\n    ", "if", " (!subCache[key]) {\r\n      subCache[key] = [];\r\n    }\r\n    ", "// 添加到订阅缓存中", "\r\n    subCache[key].push(fn);\r\n    ", "// 如果有发布记录，则直接执行函数", "\r\n    ", "if", " (pubCache[key]) {\r\n      ", "if", " (paramCache[key]) {\r\n        fn.apply(", "null", ", paramCache[key]);\r\n      } ", "else", " {\r\n        fn.apply(", "null", ");\r\n      }\r\n      pubCache[key] = ", "undefined", ";\r\n    }\r\n  };\r\n  pub = ", "function", " (", ") ", "{\r\n    ", "var", " key = ", "Array", ".prototype.shift.call(", "arguments", ");\r\n    ", "var", " fns = subCache[key];\r\n    ", "// 没有订阅过，则将参数缓存，待订阅的时候直接执行", "\r\n    ", "if", " (!fns || fns.length === ", "0", ") {\r\n      pubCache[key] = ", "true", ";\r\n      paramCache[key] = ", "Array", ".prototype.slice.call(", "arguments", ", ", "0", ");\r\n      ", "return", ";\r\n    }\r\n    ", "// 有订阅记录，则直接执行", "\r\n    ", "for", " (", "let", " fn ", "of", " fns) {\r\n      fn.apply(", "null", ", ", "arguments", ");\r\n    }\r\n  };\r\n  remove = ", "function", " (", "key", ") ", "{\r\n    ", "// 把所有的缓存全部清除", "\r\n    subCache[key] = ", "undefined", ";\r\n    pubCache[key] = ", "undefined", ";\r\n    paramCache[key] = ", "undefined", ";\r\n  };\r\n  ", "return", " {\r\n    ", "pub", ": pub,\r\n    ", "sub", ": sub,\r\n    ", "remove", ": remove\r\n  };\r\n})();\r\n\r\n", "module", ".exports = MyEvent;", "使用方法如下：", "在appjs里引入MyEvent，并挂载在wx对象上", "App({\r\n  onLaunch: ", "function", " ", "()", " ", "{\r\n    ", "const", " MyEvent = ", "require", "(", "'myEvent的路径'", ");\r\n    wx.myEvent = MyEvent;\r\n  }\r\n})", "在其中页面页面1的onShow里订阅test1事件，发布test2事件", "onLoad: ", "function", "(", ")", "{\r\n    wx.myEvent.sub(", "'test1'", ", ", "function", " (", ") ", "{\r\n        ", "console", ".log(", "'test1'", ");\r\n    });\r\n},\r\n", "onShow", ": ", "function", " (", ") ", "{\r\n    wx.myEvent.pub(", "'test2'", ", ", "'test2'", " + ", "new", " ", "Date", "().getTime());\r\n}", "在页面2的onLoad事件里，发布test1事件，订阅test2事件", "onLoad: ", "function", "(", "options", ") ", "{\r\n    wx.myEvent.pub(", "'test1'", ");\r\n    wx.myEvent.sub(", "'test2'", ", ", "function", "(", "a", ")", "{\r\n      ", "console", ".log(a);\r\n    });\r\n}", "一. 在页面1的时候，执行了订阅test1事件，发布了test2事件，但是test1没有发布，订阅的事件不会执行，test2事件没有订阅，也不会执行。", "二. 从页面1跳转到页面2，发布了test1事件，直接执行之前已经注册好的test1事件，订阅test2事件，因为有test2的发布事件，订阅之后直接执行，结果是打印一次test1，打印一次test2。", "三. 从页面2返回到页面1，执行onShow事件，再次发布test2事件，打印一次test2", "四. 从页面1到页面2，发布了test1事件，事件test2重复订阅了，订阅了两次，打印一次test1。", "五. 从页面2返回页面1，发布test2，因为test2事件订阅了两次，所以打印了两次test2，所以要注意在不需要的地方把事件注销。", "在页面2的onUnload事件里把事件test2注销掉，在从页面2回到页面1的时候，事件test2已经注销了，不会再执行。", "onUnload: ", "function", "()", " {\r\n    wx.myEvent.remove(", "'test2'", ");\r\n}", "原理和用法说明：", "原理：", "全局只有一个wx对象，将myEvent挂载在wx上，所以全局也只有一个wx.myEvent对象，myEvent里用到了闭包，订阅的函数和参数都有保存在内存里，所以能实现订阅和发布的功能。", "目前事件订阅是用的数组存储，可实现同一个事件订阅多次，如果不需要的话可自行修改成只能订阅一次的方法。", "用法：", "一般用于跨页面的操作，比如在某个页面订阅某个事件，在另一份页面执行了某项操作之后，发布该事件，会直接执行订阅的事件，实现页面间的一些数据传递。", "还有也可用于异步请求，先订阅某个事件，异步请求数据，请求数据回来之后，再发布。", "待补充......", " "]}
{"title": "微信小程序之SelectorQuery ", "author": "Rolan", "pub_time": "2019-5-16 00:12", "content": [" \n                     \n                    ", "在开发", "小程序", "展开全文组件时需要用到节点查询API - wx.createSelectorQuery() 来查询全文内容的高度。", "wx.createSelectorQuery() 返回一个 SelectorQuery 对象实例。", "SelectorQuery 有五个方法（in，select，selectAll，selectViewport，exec），第一个返回 SelectorQuery，后四个返回 NodesRef。", "NodesRef 有四个方法（fields，boundingClientRect，scrollOffset，context），第一个返回 NodesRef，后三个返回 SelectorQuery。", "对照官方提供的示例代码来看", "const", " query = wx.createSelectorQuery() ", "// query 是 SelectorQuery 对象", "\r\nquery.select(", "'#the-id'", ").boundingClientRect() ", "// select 后是 NodesRef 对象，然后 boundingClientRect 返回 SelectorQuery 对象", "\r\nquery.selectViewport().scrollOffset() ", "// selectViewport 后是 NodesRef 对象，然后 scrollOffset 返回 SelectorQuery 对象", "\r\nquery.exec(", "function", " ", "(res)", " ", "{ ", "// exec 返回 NodesRef 对象", "\r\n  res[", "0", "].top ", "// #the-id节点的上边界坐标", "\r\n  res[", "1", "].scrollTop ", "// 显示区域的竖直滚动位置", "\r\n})", "问题：每行执行返回的 SelectorQuery 对象是相同的吗？", "答案：是的，都是同一个对象。", "问题：直接执行 query.select('#the-id').boundingClientRect().exec 也可以吗？", "答案：可以，boundingClientRect() 返回就是 query。", "问题：这样连写 query.select('#the-id').boundingClientRect().selectViewport().scrollOffset() 算两条查询请求吗？", "答案：是两条请求。", "问题：query.exec 执行后会清空前面的查询请求吗？再次执行还能拿到结果吗？", "答案：可以，query不会清空请求。", "问题：boundingClientRect 和 scrollOffset 可以接受 callback 参数，它与 query.exec 执行顺序是怎样，修改 res 结果会影响到后面的 callback 吗？", "答案：先执行 boundingClientRect 和 scrollOffset 的 callback，再执行 query.exec 的 callback；修改 res 结果会影响到后面 exec 的结果。", "上面的问题通过 WAService.js 源码简单美化后可以了解 SelectorQuery 的代码逻辑", "class", " ", "NodesRef", " ", "{\r\n  ", "constructor", "(selectorQuery, component, selector, single) {\r\n    ", "this", "._selectorQuery = selectorQuery;\r\n    ", "this", "._component = component;\r\n    ", "this", "._selector = selector;\r\n    ", "this", "._single = single;\r\n  }\r\n  fields(e, t) {\r\n    ", "this", "._selectorQuery._push(", "this", "._selector, ", "this", "._component, ", "this", "._single,\r\n      e,\r\n      t,\r\n    );\r\n    ", "return", " ", "this", "._selectorQuery\r\n  }\r\n  boundingClientRect(callback) {\r\n    ", "this", "._selectorQuery._push( ", "this", "._selector, ", "this", "._component, ", "this", "._single,\r\n      {\r\n        id: ", "true", ",\r\n        dataset: ", "true", ",\r\n        rect: ", "true", ",\r\n        size: ", "true", ",\r\n      },\r\n      callback,\r\n    );\r\n    ", "return", " ", "this", "._selectorQuery;\r\n  }\r\n  scrollOffset(callback) {\r\n    ", "this", "._selectorQuery._push( ", "this", "._selector, ", "this", "._component, ", "this", "._single,\r\n      {\r\n        id: ", "true", ",\r\n        dataset: ", "true", ",\r\n        scrollOffset: ", "true", ",\r\n      },\r\n      callback,\r\n    );\r\n    ", "return", " ", "this", "._selectorQuery;\r\n  }\r\n}\r\n\r\nlet pluginId = ", "''", ";\r\n", "class", " ", "SelectorQuery", " ", "{\r\n  ", "constructor", "(e) {\r\n    ", "if", " (e && e.page) {\r\n      ", "this", "._component = ", "this", "._defaultComponent = e.page;\r\n      ", "this", "._webviewId = ", "this", "._defaultComponent.__wxWebviewId__;\r\n    } ", "else", " {\r\n      ", "var", " pages = __internalGlobal__.getCurrentPagesByDomain(", "''", ");\r\n      ", "this", "._defaultComponent = pages[pages.length - ", "1", "],\r\n      ", "this", "._component = ", "null", ";\r\n      ", "this", "._webviewId = ", "null", ";\r\n    }\r\n    ", "this", "._queue = [];\r\n    ", "this", "._queueCb = [];\r\n  }\r\n  ", "in", "(component) {\r\n    ", "if", " (!", "this", "._webviewId) {\r\n      ", "this", "._webviewId = component.__wxWebviewId__;\r\n      ", "this", "._component = component;\r\n    } ", "else", " ", "if", " (", "this", "._webviewId !== component.__wxWebviewId__) {\r\n      console.error(", "'A single SelectorQuery could not work in components in different pages. A SelectorQuery#in call has been ignored.'", ");\r\n    } ", "else", " {\r\n      ", "this", "._component = component;\r\n    }\r\n    ", "return", " ", "this", ";\r\n  }\r\n  select(selector) {\r\n    ", "return", " new NodesRef(", "this", ", ", "this", "._component, selector, ", "true", ");\r\n  }\r\n  selectAll(selector) {\r\n    ", "return", " new NodesRef(", "this", ", ", "this", "._component, selector, ", "false", ");\r\n  }\r\n  selectViewport() {\r\n    ", "return", " new NodesRef(", "this", ", ", "0", ", ", "''", ", ", "true", ");\r\n  }\r\n  _push(selector, component, single, fields, callback) {\r\n    ", "if", " (!", "this", "._webviewId) {\r\n      ", "this", "._webviewId = ", "this", "._defaultComponent ? ", "this", "._defaultComponent.__wxWebviewId__ : undefined;\r\n    }\r\n    const rootNodeId = pluginId ? ", "''", " : r.getRootNodeId(", "this", "._webviewId);\r\n    ", "this", "._queue.push({\r\n      component: ", "null", " != component ? (", "0", " === component ? ", "0", " : component.__wxExparserNodeId__) : rootNodeId,\r\n      selector,\r\n      single,\r\n      fields,\r\n    });\r\n    ", "this", "._queueCb.push(callback || ", "null", ");\r\n  }\r\n  exec(callback) {\r\n    hd(", "this", "._webviewId, {\r\n      pluginId,\r\n      queue: ", "this", "._queue,\r\n    }, (results) => {\r\n      const queueCb = ", "this", "._queueCb;\r\n      results.forEach((res, index) => {\r\n        ", "if", " (", "'function'", " == typeof queueCb[index]) {\r\n          queueCb[index].call(", "this", ", res);\r\n        }\r\n      });\r\n      ", "if", " (", "'function'", " == typeof callback) {\r\n        callback.call(", "this", ", results);\r\n      }\r\n    })\r\n  }\r\n}", " "]}
{"title": "小程序 多图列表 性能优化 ", "author": "Rolan", "pub_time": "2019-5-29 00:32", "content": [" \n                     \n                    ", "小程序", " 多图列表 性能优化", "写这篇文章的缘由: 最近在公司的小程序项目中遇到了页面图片元素过多导致的性能问题. 从小程序提供的性能检测面板分析, 确定是图片元素占用了过多内存导致.", "因为本人之前主要是做桌面端应用开发和原生app开发, 没有太顾及过移动端图片的内存占用问题. 这次既然遇到了, 也就趁这个机会学习一下其优化的技巧.", "什么造成的性能问题", "简单的来说: ", "DOM节点过多", " && ", "图片节点过多", "DOM节点过多会造成更多的内存占用. 按照目前的微信小程序限制, 内存占用500M以上会出现卡顿, 甚至闪退. 如果列表中节点没有图片标签, 内存占用现象还不会太明显, 只是DOM节点过多会造成页面渲染耗时增加. 但当列表节点中含有图片时, 内存占用会迅速攀升.", "如何解决这两点呢?", "对于上面两点, 我们分别有对应的优化思路", "1. DOM节点过多.", "对于无限加载的页面, 列表中每一个元素都有大量的子节点. 当列表数目增加时, 页面的总节点数会暴增. 以小红书的小程序为例:", "上图中可以看到, 该页面为很多的卡片组成的列表页面. 假设一个卡片的DOM子节点数为 30, 那么当列表元素加载到1000时, 页面会有 ", "30 * 1000 = 30,000", " 个DOM节点. 小程序显然是吃不消的 (注: 微信小程序推荐总节点数不超过: ", "1000", " )", "那我们该如何处理来减少节点数呢?", "思路很简单: 我们可以只对用户当前屏幕和上下两屏进行真实内容的加载, 对于其他用户暂时不可见的地方, 用空白的节点进行占位. 这样处理后, 实际有内容的卡片数目不超过5个, 页面的总节点数为: ", "5 * 30 + 995 = 1145", " . 相对于之前的节点数有了巨大的改进.", "让我们来看看代码的实现", "写代码前, 让我们整理一下需要的数据结构.", "首先这是一个列表页面, 我们需要一个 List来保存页面显示的数据: ", "showCards", " . ", "showCards", " 中只会保存5条真实数据, 其余数据展示以空对象填充.", "我们还需要一个保存所有真实数据的List, 这样当用户滑动页面时, 我们才能实时获取需要显示的卡片真实数据: ", "totalCards", "Page", "({\r\n  ", "showCards", ": [],\r\n  totalCards: []\r\n})", "接下来我们来写页面布局部分:", "<", "view", " ", "wx:for", "=", "\"", "{{showCards}", "}\"", "\r\n        ", "wx:key", "=", "\"", "{{index}", "}\"", ">", "\r\n\r\n    ", "<", "self-define-component", " ", "data-card-data", "=", "\"", "{{item}", "}\"", ">", "\r\n    ", "</", "self-define-component", ">", "\r\n    \r\n", "</", "view", ">", "简单的代码框架就是这样 (这里省略了很多不影响理解思路的代码细节)", "我们先实现没有优化DOM节点的代码逻辑. 在页面滑动到最底部时, 向 ", "showCards", " push进新的卡片, 并通过 ", "setData", " 更新页面. 这样就实现了一个简单的下拉无限加载的列表页面.", "async onReachBottom() {\r\n    const newCards = await fetchNewCards();\r\n  ", "this", ".", "data", ".showCards.push(newCards);\r\n  ", "this", ".setData({\r\n    showCards: ", "this", ".", "data", ".showCards\r\n  })\r\n},", "接下来我们实现优化DOM节点的代码逻辑.我们会再用户滑动页面( ", "onScroll", " 事件) 时, 对当前页面每个 ", "card", " 的位置进行判断, 如果该 card在用户可见范围内的上下两屏内, 则展示真实数据, 否则将其替换为宽高与原卡片一致的空白占位节点.", "在 Page 的 ", "onPageScroll", " 回调中, 我们进行回收函数的调用 (注意这里回调时要进行 ", "节流", " 处理, 否则频繁调用会导致页面闪动) . 让我们看看这个回收页面节点函数的主要逻辑:", "回调中, 我们首先通过小程序提供的获取页面元素位置的api: ", "createSelectorQuery().boundingClientRect", " 来拿到每个卡片的位置信息.", "接下来, 我们通过位置信息, 判断是否展示card的真实数据. 对于不展示真实数据的card, 我们需要保存其高度信息, 以便在渲染页面时使用高度信息填充页面. 同时我们给空card一个 type 属性, 方便我们在 wxml中渲染时判断卡片类型.", "async", " onScrollCallback() {\r\n  ", "try", " {\r\n    ", "const", " rectList = ", "await", " ", "this", ".calcCardsHeight();\r\n    ", "this", ".recycleCard(rectList);\r\n  } ", "catch", " (e) {\r\n    ", "console", ".error(e);\r\n  }\r\n}\r\n  calcFeedHeight() {\r\n    ", "return", " ", "new", " ", "Promise", "(", "(", "resolve, reject", ") =>", " {\r\n      ", "this", ".createSelectorQuery()\r\n        .selectAll(", "`.card`", ")\r\n        .boundingClientRect(", "rectList", " =>", " {\r\n          resolve(rectList);\r\n        })\r\n        .exec()\r\n    })\r\n  },\r\n\r\n  recycleCard(rectList) {\r\n    ", "const", " newShowCards = [];\r\n    ", "for", " (", "let", " i = ", "0", "; i < ", "this", ".data.showCards.length; i++) {\r\n      ", "const", " rect = rectList[i];\r\n      ", "if", " (rect && ", "Math", ".abs(rectList[i].top - ", "0", ") > pageHeight * ", "2", ") {\r\n        newShowCards.push({\r\n          ", "type", ": ", "'empty-card'", ",\r\n          ", "height", ": rectList[i].bottom - rectList[i].top\r\n        });\r\n      } ", "else", " {\r\n          ", "const", " feed = totalCards[i];\r\n        newShowCards.push(feed);\r\n      }\r\n    }\r\n    ", "this", ".setData({\r\n      ", "showCards", ": newShowCards\r\n    });\r\n  }", "接下来, 我们要对wxml布局文件进行相应的修改:", "<", "view", " ", "wx:for", "=", "\"", "{{showCards}", "}\"", "\r\n        ", "wx:key", "=", "\"", "{{index}", "}\"", ">", "\r\n\r\n    ", "<", "view", " ", "wx:if", "=", "\"", "{{item.type === 'empty-card'}", "}\"", "\r\n          ", "class", "=", "\"card empty-card\"", "\r\n          ", "style", "=", "\"height: ", "{{item.height}", "}px\"", ">", "\r\n    ", "</", "view", ">", "\r\n\r\n    ", "<", "self-define-component", "  ", "wx:if", "=", "\"", "{{item.type !== 'empty-card'}", "}\"", "\r\n                ", "data-card-data", "=", "\"", "{{item}", "}\"", "\r\n                ", "class", "=", "\"card read-card\"", ">", "\r\n    ", "</", "self-define-component", ">", "\r\n    \r\n  ", "</", "view", ">", "这样, 我们就解决了 DOM节点数目过多的问题. 并且最大限度的不影响用户的体验. (虽然用户快速上下滑动时还是会看到一些空白, 但大多数情况用户不会非常快速的上下滑, 而是阅读内容并慢速滑动)", "2. 图片节点过多", "通过上面一步的优化, 我们其实已经大幅减少了页面加载的图片数目. 但是有些情况, 我们的列表中的每一个卡片并不是只有一张图, 有时我们的图片组件是一个 ", "swiper", " . 我们假设每个swiper平均展示10张图片, 那么我们展示5张card的话, ", "<Image/>", " 节点就有 ", "50", " 个. 对于一些低端的安卓机, 这样的开销依然会造成卡顿.", "那有什么好的优化方案呢? 前面一个问题, 我们的优化思路是在用户看不见的地方, 将节点简化展示.", "同样的, 对于swiper控件, 用户能看到的也就是 ", "当前图片", " 以及 ", "滑动可见的左右两张图片", " . 其余位置的图片是可以简化展示的. 从下图可以看到, 其实需要立即加载的图片只有三张. (红色的框代表的是swiper组件的可视区域)", "我们使用一个变量记录当前swiper控件展示图片的坐标: ", "curIndex", " , 然后我们改造一下 wxml布局文件. 代码逻辑很简单, 就是通过判断当前Image 节点的index和swiper展示节点的 index之间距离, 大于2就不显示.", "经过这样的处理后, 我们的每个swiper组件, 最多只会有三个占用实际内存的 ", "<Image/>", " 节点.", "<", "swiper-item", " ", "wx:for", "=", "\"", "{{images}", "}\"", "\r\n                   ", "wx:key", "=", "\"", "{{index}", "}\"", ">", "\r\n\r\n        ", "<", "view", " >", "\r\n          ", "<", "image", " ", "class", "=", "\"img\"", "\r\n                 ", "mode", "=", "\"widthFix\"", "\r\n                 ", "src", "=", "\"", "{{index - curIndex < 2 && index - curIndex > -2 ? item.url : ''}", "}\"", ">", "\r\n          ", "</", "image", ">", "\r\n        ", "</", "view", ">", "\r\n      ", "</", "swiper-item", ">", "最后", "以上就是我在这次性能优化中用到的一些小技巧, 希望能为你带来一些帮助 :)", "如果你对我的文章感兴趣, 这里有我的一些 ", "数据可视化", " ， ", "D3.js", " 方面的文章， 欢迎 fork && star：", "https://github.com/ssthouse/s...", " "]}
{"title": "微信小程序WebSocket实践 ", "author": "Rolan", "pub_time": "2019-6-5 00:23", "content": [" \n                     \n                    ", "微信基础库1.7.0之后的版本提供了新版的WebSocket API，考虑到兼容性问题，尝试整合新旧两种版本的API，进行简单的封装。", "从以下几个角度对微信", "小程序", "中所提供的WebSocket API封装", "API兼容性", "重连机制", "小程序WebSocket API", "旧版WebSocket API的使用", "创建 - wx.connectSocket", "发送消息 - sendSocketMessage", "监听事件 - onSocketOpen", "let", " socketOpen = ", "false", "\r\n", "const", " socketMsgQueue = []\r\n", "// 连接socket", "\r\nwx.connectSocket({\r\n  ", "url", ": ", "'test.php'", "\r\n})\r\n", "// 监听打开事件", "\r\nwx.onSocketOpen(", "function", "(", "res", ") ", "{\r\n  socketOpen = ", "true", "\r\n  ", "for", " (", "let", " i = ", "0", "; i < socketMsgQueue.length; i++){\r\n    sendSocketMessage(socketMsgQueue[i])\r\n  }\r\n  socketMsgQueue = []\r\n})\r\n", "// 发送消息", "\r\n", "function", " ", "sendSocketMessage", "(", "msg", ") ", "{\r\n  ", "if", " (socketOpen) {\r\n    wx.sendSocketMessage({\r\n      ", "data", ":msg\r\n    })\r\n  } ", "else", " {\r\n    socketMsgQueue.push(msg)\r\n  }\r\n}", "新版WebSocket API的使用", "支持1.7.0+，连接后会返回一个SocketTask对象，在该对象上监听该连接的各种事件与执行发送消息等操作。", "let", " socketTask = wx.connectSocket({\r\n  ", "url", ": ", "'test.php'", "\r\n})\r\n", "// 监听打开事件", "\r\nsocketTask.onOpen(", "function", "(", "res", ") ", "{\r\n  socketOpen = ", "true", "\r\n  ", "// 发送信息", "\r\n  socketTask.send({", "msg", ": ", "\"hello world\"", "})\r\n})", "并发数", "1.7.0", " 及以上版本，最多可以同时存在\t", "5", " 个\t", "WebSocket", " 连接。", "1.7.0", " 以下版本，一个小程序同时只能有一个\t", "WebSocket", " 连接，如果当前已存在一个 WebSocket 连接，会自动关闭该连接，并重新创建一个\t", "WebSocket", " 连接。", "模块封装", "简单封装封装一个兼容新旧socketAPI的模块，仅考虑存在单个socket连接的情况", "创建与事件监听", "新版: 在socket连接时会返回一个socketTask对象，监听事件是在该对象的基础上进行", "旧版: 直接使用wx放进行创建与监听方法", "统一创建与添加监听函数", "init() {\r\n  let st = ", "this", ".connect()\r\n  ", "this", ".listen(st)\r\n  ", "this", ".manualClose = ", "false", "\r\n}", "创建连接", "connect() {\r\n  let st = wx.connectSocket(", "this", ".config.server)\r\n  ", "return", " st\r\n}", "添加事件监听函数", "listen(st) {\r\n  ", "if", " (st !== ", "undefined", ") {\r\n    ", "this", ".ws = st\r\n    ", "this", ".ws.onOpen(", "()", " =>", " ", "this", ".openHandle())\r\n    ", "this", ".ws.onError(", "()", " =>", " ", "this", ".errorHandle())\r\n    ", "this", ".ws.onClose(", "()", " =>", " ", "this", ".closeHandle())\r\n    ", "this", ".ws.onMessage(res => ", "this", ".messageHandle(res))\r\n  } ", "else", " {\r\n    wx.onSocketOpen(", "()", " =>", " ", "this", ".openHandle())\r\n    wx.onSocketError(", "()", " =>", " ", "this", ".errorHandle())\r\n    wx.onSocketClose(", "()", " =>", " ", "this", ".closeHandle())\r\n    wx.onSocketMessage(res => ", "this", ".messageHandle(res))\r\n  }\r\n}", "重连机制", "预设标记位", "retryLock", " = ", "false", "; // 避免多次同时重连\r\n", "socketOpen", " = ", "false", "; // 连接状态\r\n", "manualClose", " = ", "false", "; // 主动断开标记", "在连接关闭监听函数中执行重连", "closeHandle() {\r\n  console.info(", "'WebSocket closed'", ")\r\n  ", "this", ".socketOpen = ", "false", "\r\n  ", "this", ".retryLock = ", "false", "\r\n  ", "// 不论是error还是close都会触发close事件，统一在这里进行重连", "\r\n  ", "// 初次连接失败不进行重连(失败不会进入到onOpen的监听事件中，那时未声明retryTimes变量)", "\r\n  ", "this", ".retryTimes !== undefined && ", "this", ".reconnect()\r\n}", "判断重连锁与是否主动断开进行重连", "reconnect() {\r\n  ", "if", " (", "this", ".retryLock) ", "return", "\r\n  ", "this", ".retryLock = ", "true", "\r\n  ", "// 若manualClose为true，表明不是主动断开", "\r\n  ", "if", " (!", "this", ".manualClose) {\r\n    ", "// 开始重连", "\r\n    setTimeout(() => {\r\n      ", "this", ".retry()\r\n    }, ", "this", ".retryInterval)\r\n  }\r\n}", "重连函数，包含重连次数的限制", "retry() {\r\n  ", "if", " (\r\n    ", "this", ".socketOpen ||\r\n    (", "this", ".retryTimes > ", "0", " && ", "this", ".retryCount <= ", "this", ".retryTimes)\r\n  ) {\r\n    console.warn(`reconnect ending. reconnect ${", "this", ".retryTimes} times`)\r\n    ", "if", " (!", "this", ".socketOpen) {\r\n      ", "this", ".config.closeCallback()\r\n    }\r\n    ", "return", "\r\n  }\r\n  ", "this", ".retryTimes += ", "1", "\r\n  console.warn(`[ ${", "this", ".retryTimes} ]th reconnect WebSocket...`)\r\n  ", "this", ".init()\r\n}", "消息队列", "添加消息队列，当重连后自动发送缓存消息", "openHandle() {\r\n  ", "this", ".retryTimes = ", "0", "\r\n  ", "this", ".socketOpen = ", "true", "\r\n  ", "this", ".retryLock = ", "false", "\r\n\r\n  ", "this", ".messageQueue.map(e => ", "this", ".send(e))\r\n  ", "this", ".messageQueue = []\r\n}", "若发送时断开则先将消息缓存到消息队列中", "send(value) {\r\n  let ", "data", " = ", "this", ".msgWrapper(value)\r\n  ", "data", " = JSON.stringify(", "data", ")\r\n  ", "if", " (!", "this", ".socketOpen) {\r\n    ", "this", ".messageQueue.push(", "data", ")\r\n  } ", "else", " {\r\n    ", "if", " (", "this", ".ws) {\r\n      ", "this", ".ws.send({ ", "data", " })\r\n    } ", "else", " {\r\n      wx.sendSocketMessage({ ", "data", " })\r\n    }\r\n  }\r\n}", "辅助函数", "添加一些包裹消息格式的工具函数", "messageIndex = ", "0", ";\r\nhelper = {\r\n  isPlainObject: ", "val", " =>\r\n    Object.prototype.toString.call(", "val", ") === ", "'[object Object]'", ",\r\n  nextId: () => {\r\n    ", "this", ".messageIndex += ", "1", "\r\n    ", "return", " ", "this", ".messageIndex\r\n  },\r\n  id: () => Date.now() + ", "'.'", " + ", "this", ".helper.nextId()\r\n};\r\nmsgWrapper(", "data", ") {\r\n  let msg = ", "data", "\r\n  ", "if", " (", "this", ".helper.isPlainObject(msg)) {\r\n    ", "if", " (msg.type) {\r\n      ", "return", " msg\r\n    } ", "else", " {\r\n      ", "return", " ", "this", ".msgWrapper({ type: ", "'message'", ", msg, id: ", "this", ".helper.id() })\r\n    }\r\n  } ", "else", " {\r\n    ", "return", " ", "this", ".msgWrapper({ type: ", "'message'", ", msg, id: ", "this", ".helper.id() })\r\n  }\r\n}", "完整代码", "export ", "default", " ", "class", " ", "WXWebSocket", " ", "{\r\n  messageQueue = []; ", "// 消息队列", "\r\n  retryLock = ", "false", "; ", "// 避免多次同时重连", "\r\n  socketOpen = ", "false", ";\r\n  manualClose = ", "false", "; ", "// 主动断开标记", "\r\n  ", "constructor", "(config) {\r\n    ", "this", ".config = config || {}\r\n    ", "// 重连间隔", "\r\n    ", "this", ".retryInterval =\r\n      ", "this", ".config.retryInterval && ", "this", ".config.retryInterval > ", "100", "\r\n        ? ", "this", ".config.retryInterval\r\n        : ", "3000", "\r\n    ", "// 重连次数", "\r\n    ", "this", ".retryCount = ", "this", ".config.retryCount || ", "5", "\r\n    ", "this", ".init()\r\n  }\r\n  init() {\r\n    let st = ", "this", ".connect()\r\n    ", "this", ".listen(st)\r\n    ", "this", ".manualClose = ", "false", "\r\n  }\r\n  connect() {\r\n    let st = wx.connectSocket(", "this", ".config.server)\r\n    console.log(", "'current socket: '", ", st)\r\n    ", "return", " st\r\n  }\r\n  listen(st) {\r\n    ", "// 添加监听事件", "\r\n    ", "if", " (st !== undefined) {\r\n      ", "// 若存在SocketTask，则要通过readyState判断状态", "\r\n      ", "// CONNECTING: 0", "\r\n      ", "// OPEN: 1", "\r\n      ", "// CLOSING: 2", "\r\n      ", "// CLOSE: 3", "\r\n      ", "this", ".ws = st\r\n      ", "this", ".ws.onOpen(() => ", "this", ".openHandle())\r\n      ", "this", ".ws.onError(() => ", "this", ".errorHandle())\r\n      ", "this", ".ws.onClose(() => ", "this", ".closeHandle())\r\n      ", "this", ".ws.onMessage(res => ", "this", ".messageHandle(res))\r\n    } ", "else", " {\r\n      wx.onSocketOpen(() => ", "this", ".openHandle())\r\n      wx.onSocketError(() => ", "this", ".errorHandle())\r\n      wx.onSocketClose(() => ", "this", ".closeHandle())\r\n      wx.onSocketMessage(res => ", "this", ".messageHandle(res))\r\n    }\r\n  }\r\n  close() {\r\n    ", "this", ".manualClose = ", "true", "\r\n    ", "if", " (", "this", ".ws) {\r\n      ", "this", ".ws.close()\r\n    } ", "else", " {\r\n      wx.closeSocket()\r\n    }\r\n  }\r\n  send(value) {\r\n    console.log(", "'send value: '", ", value)\r\n    let ", "data", " = ", "this", ".msgWrapper(value)\r\n    ", "data", " = JSON.stringify(", "data", ")\r\n    ", "if", " (!", "this", ".socketOpen) {\r\n      ", "// add new message to queue", "\r\n      ", "this", ".messageQueue.push(", "data", ")\r\n    } ", "else", " {\r\n      ", "if", " (", "this", ".ws) {\r\n        ", "this", ".ws.send({ ", "data", " })\r\n      } ", "else", " {\r\n        wx.sendSocketMessage({ ", "data", " })\r\n      }\r\n    }\r\n  }\r\n  openHandle() {\r\n    console.info(", "'WebSocket connected'", ")\r\n    ", "this", ".retryTimes = ", "0", "\r\n    ", "this", ".socketOpen = ", "true", "\r\n    ", "this", ".retryLock = ", "false", "\r\n\r\n    ", "this", ".messageQueue.map(e => ", "this", ".send(e))\r\n    ", "this", ".messageQueue = []\r\n  }\r\n  errorHandle() {\r\n    console.error(", "'WebSocket error'", ")\r\n    ", "this", ".socketOpen = ", "false", "\r\n  }\r\n  closeHandle() {\r\n    console.info(", "'WebSocket closed'", ")\r\n    ", "this", ".socketOpen = ", "false", "\r\n    ", "this", ".retryLock = ", "false", "\r\n    ", "// 不论是error还是close都会触发close事件，统一在这里进行重连", "\r\n    ", "// 初次连接失败不进行重连(失败不会进入到onOpen的监听事件中，那时未声明retryTimes变量)", "\r\n    ", "this", ".retryTimes !== undefined && ", "this", ".reconnect()\r\n  }\r\n  reconnect() {\r\n    ", "if", " (", "this", ".retryLock) ", "return", "\r\n    ", "this", ".retryLock = ", "true", "\r\n    ", "// 若manualClose为true，表明不是主动断开", "\r\n    ", "if", " (!", "this", ".manualClose) {\r\n      ", "// 开始重连", "\r\n      setTimeout(() => {\r\n        ", "this", ".retry()\r\n      }, ", "this", ".retryInterval)\r\n    }\r\n  }\r\n  retry() {\r\n    ", "if", " (\r\n      ", "this", ".socketOpen ||\r\n      (", "this", ".retryTimes > ", "0", " && ", "this", ".retryCount <= ", "this", ".retryTimes)\r\n    ) {\r\n      console.warn(`end reconnect. reconnect ${", "this", ".retryTimes} times`)\r\n      ", "if", " (!", "this", ".socketOpen) {\r\n        ", "this", ".config.closeCallback()\r\n      }\r\n      ", "return", "\r\n    }\r\n    ", "this", ".retryTimes += ", "1", "\r\n    console.warn(`[ ${", "this", ".retryTimes} ]th reconnect WebSocket...`)\r\n    ", "this", ".init()\r\n  }\r\n  messageHandle(res) {\r\n    ", "this", ".config.responseCallback(res)\r\n  }\r\n  msgWrapper(", "data", ") {\r\n    let msg = ", "data", "\r\n    ", "if", " (", "this", ".helper.isPlainObject(msg)) {\r\n      ", "if", " (msg.type) {\r\n        ", "return", " msg\r\n      } ", "else", " {\r\n        ", "return", " ", "this", ".msgWrapper({ type: ", "'message'", ", msg, id: ", "this", ".helper.id() })\r\n      }\r\n    } ", "else", " {\r\n      ", "return", " ", "this", ".msgWrapper({ type: ", "'message'", ", msg, id: ", "this", ".helper.id() })\r\n    }\r\n  }\r\n  messageIndex = ", "0", ";\r\n  helper = {\r\n    isPlainObject: ", "val", " =>\r\n      Object.prototype.toString.call(", "val", ") === ", "'[object Object]'", ",\r\n    nextId: () => {\r\n      ", "this", ".messageIndex += ", "1", "\r\n      ", "return", " ", "this", ".messageIndex\r\n    },\r\n    id: () => Date.now() + ", "'.'", " + ", "this", ".helper.nextId()\r\n  };\r\n}", "使用", "创建连接", "let", " socketTask = ", "new", " WXWebSocket({\r\n  ", "server", ": ", "this", ".wsServerOption,\r\n  ", "responseCallback", ": ", "e", " =>", " {\r\n    ", "let", " { data } = e\r\n    ", "let", " { msg } = ", "JSON", ".parse(data)\r\n    ", "this", ".msgStack.push(msg)\r\n  },\r\n  ", "closeCallback", ": ", "()", " =>", " {\r\n    ", "this", ".socketTask = ", "null", "\r\n  }\r\n})\r\n", "this", ".socketTask = socketTask", "发送消息", "sendWSMessage(msg) {\r\n  ", "this", ".msgStack.push(msg)\r\n  ", "this", ".socketTask && ", "this", ".socketTask.send(msg)\r\n},", "关闭连接", "closeWS() {\r\n  ", "if", " (!", "this", ".socketTask) ", "return", "\r\n  ", "if", " (", "this", ".socketTask.socketOpen) {\r\n    ", "this", ".socketTask.close()\r\n    ", "this", ".socketTask = ", "null", "\r\n  }\r\n}", " "]}
{"title": "通过json用canvas生成分享海报,支持微信小程序和web ", "author": "Rolan", "pub_time": "2019-6-19 00:39", "content": [" \n                     \n                    ", "需求", "在项目里写过几个canvas生成分享海报页面后,觉得这是个重复且冗余的工作.于是就想有没有能通过类似json直接生成海报的库.", "然后就在github找到到两个项目:", "wxa-plugin-canvas", " ,不太喜欢配置文件的写法.就没多去了解", "mp_canvas_drawer", " ,使用方式就比较符合直觉,不过可惜功能有点少.", "然后就想着能不能自己再造个轮子.于是就有了这个项目 ", "json2canvas", " ,你可以简单的理解为是mp_canvas_drawer的增强版吧.", "json2canvas", " canvas绘制海报,写个json就够了.", "项目的canvas绘制是基于 ", "cax", " 实现的.所以天然的带来一个好处,json2canvas同时支持", "小程序", "和web", "功能", "支持缩放. 如果设计稿是750,而画布只有375时.你不需要任何换算,只需要将scale设置为0.5即可.", "支持图片圆角", "支持圆型,矩形,矩形圆角(背景色支持线性渐变)", "长文本自动换行(感谢 coolzjy@v2ex 提供的正则 ", "https://regexr.com/4f12l", " ,优化了换行的计算方式(不会粗暴的折断单词))", "支持分组(cax里很好用的一个功能)", "同时支持小程序和web", "示例", "demo-web", " 界面左边的json,可以进行编辑,直接看效果哟~", "小程序demo", "git clone https:", "//gi", "thub.com", "/willnewii/", "json2canvas.git\r\n微信开发者工具导入项目 example", "/weapp/", "小程序安装", "npm", " i json2canvas\r\n微信开发者工具", "->", "工具", "->", "构建", "npm", "在需要使用的界面引入Component", "{\r\n  ", "\"usingComponents\"", ": {\r\n    ", "\"json2canvas\"", ":", "\"/miniprogram_npm/json2canvas/index\"", "\r\n  }\r\n}", "举个例子", "想要生成一个这样的海报,需要怎么做？(红框是图片元素,蓝框是文字元素,其余的是一张背景图。)", "简单,一个json搞定.具体支持的元素和参数,请查看项目 ", "readme", "{\r\n        ", "\"width\"", ": ", "750", ",\r\n        ", "\"height\"", ": ", "1334", ",\r\n        ", "\"scale\"", ": ", "0.5", ",\r\n        ", "\"children\"", ": [\r\n            {\r\n                ", "\"type\"", ": ", "\"image\"", ",\r\n                ", "\"url\"", ": ", "\"http://res.mayday5.me/wxapp/wxavatar/tmp/bg_concerts_1.jpg\"", ",\r\n                ", "\"width\"", ": ", "750", ",\r\n                ", "\"height\"", ": ", "1334", "\r\n            }, {\r\n                ", "\"type\"", ": ", "\"image\"", ",\r\n                ", "\"url\"", ": ", "\"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg\"", ",\r\n                ", "\"width\"", ": ", "100", ",\r\n                ", "\"x\"", ": ", "48", ",\r\n                ", "\"y\"", ": ", "44", ",\r\n                ", "\"isCircular\"", ": ", "true", ",\r\n            }, {\r\n                ", "\"type\"", ": ", "\"circle\"", ",\r\n                ", "\"r\"", ": ", "50", ",\r\n                ", "\"lineWidth\"", ": ", "5", ",\r\n                ", "\"strokeStyle\"", ": ", "\"#CCCCCC\"", ",\r\n                ", "\"x\"", ": ", "48", ",\r\n                ", "\"y\"", ": ", "44", ",\r\n            }, {\r\n                ", "\"type\"", ": ", "\"text\"", ",\r\n                ", "\"text\"", ": ", "\"歌词本\"", ",\r\n                ", "\"font\"", ": ", "\"30px Arial\"", ",\r\n                ", "\"color\"", ": ", "\"#FFFFFF\"", ",\r\n                ", "\"x\"", ": ", "168", ",\r\n                ", "\"y\"", ": ", "75", ",\r\n                ", "\"shadow\"", ": {\r\n                    ", "\"color\"", ": ", "\"#000\"", ",\r\n                    ", "\"offsetX\"", ": ", "2", ",\r\n                    ", "\"offsetY\"", ": ", "2", ",\r\n                    ", "\"blur\"", ": ", "2", "\r\n                }\r\n            }, {\r\n                ", "\"type\"", ": ", "\"image\"", ",\r\n                ", "\"url\"", ": ", "\"http://res.mayday5.me/wxapp/wxavatar/tmp/medal_concerts_1.png\"", ",\r\n                ", "\"width\"", ": ", "300", ",\r\n                ", "\"x\"", ": ", "\"center\"", ",\r\n                ", "\"y\"", ": ", "361", "\r\n            }, {\r\n                ", "\"type\"", ": ", "\"text\"", ",\r\n                ", "\"text\"", ": ", "\"一生活一场 五月天\"", ",\r\n                ", "\"font\"", ": ", "\"38px Arial\"", ",\r\n                ", "\"color\"", ": ", "\"#FFFFFF\"", ",\r\n                ", "\"x\"", ": ", "\"center\"", ",\r\n                ", "\"y\"", ": ", "838", ",\r\n                ", "\"shadow\"", ": {\r\n                    ", "\"color\"", ": ", "\"#000\"", ",\r\n                    ", "\"offsetX\"", ": ", "2", ",\r\n                    ", "\"offsetY\"", ": ", "2", ",\r\n                    ", "\"blur\"", ": ", "2", "\r\n                }\r\n            }, {\r\n                ", "\"type\"", ": ", "\"text\"", ",\r\n                ", "\"text\"", ": ", "\"北京6场，郑州2场，登船，上班，听到你想听的歌了吗？\"", ",\r\n                ", "\"font\"", ": ", "\"24px Arial\"", ",\r\n                ", "\"color\"", ": ", "\"#FFFFFF\"", ",\r\n                ", "\"x\"", ": ", "\"center\"", ",\r\n                ", "\"y\"", ": ", "888", ",\r\n                ", "\"shadow\"", ": {\r\n                    ", "\"color\"", ": ", "\"#000\"", ",\r\n                    ", "\"offsetX\"", ": ", "2", ",\r\n                    ", "\"offsetY\"", ": ", "2", ",\r\n                    ", "\"blur\"", ": ", "2", "\r\n                }\r\n            }, {\r\n                ", "\"type\"", ": ", "\"rect\"", ",\r\n                ", "\"width\"", ": ", "750", ",\r\n                ", "\"height\"", ": ", "193", ",\r\n                ", "\"fillStyle\"", ": ", "\"#FFFFFF\"", ",\r\n                ", "\"x\"", ": ", "0", ",\r\n                ", "\"y\"", ": ", "\"bottom\"", "\r\n            }, {\r\n                ", "\"type\"", ": ", "\"image\"", ",\r\n                ", "\"url\"", ": ", "\"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg\"", ",\r\n                ", "\"width\"", ": ", "117", ",\r\n                ", "\"height\"", ": ", "117", ",\r\n                ", "\"x\"", ": ", "47", ",\r\n                ", "\"y\"", ": ", "1180", "\r\n            }, {\r\n                ", "\"type\"", ": ", "\"text\"", ",\r\n                ", "\"text\"", ": ", "\"长按识别小程序二维码\"", ",\r\n                ", "\"font\"", ": ", "\"26px Arial\"", ",\r\n                ", "\"color\"", ": ", "\"#858687\"", ",\r\n                ", "\"x\"", ": ", "192", ",\r\n                ", "\"y\"", ": ", "1202", "\r\n            }, {\r\n                ", "\"type\"", ": ", "\"text\"", ",\r\n                ", "\"text\"", ": ", "\"加入五月天 永远不会太迟\"", ",\r\n                ", "\"font\"", ": ", "\"18px Arial\"", ",\r\n                ", "\"color\"", ": ", "\"#A4A5A6\"", ",\r\n                ", "\"x\"", ": ", "192", ",\r\n                ", "\"y\"", ": ", "1249", "\r\n            }]\r\n    }", "问题反馈", "有什么问题可以直接 ", "提issue", " "]}
{"title": "微信小程序实战教程——2实战之模仿知乎 ", "author": "Rolan", "pub_time": "2019-6-25 00:42", "content": [" \n                     \n                    ", "除了", "小程序", "项目中自带的文件夹，我引入了几个新的文件夹：", ".vscode文件夹存放vscode编辑器的配置文件。", "components文件夹存放组件。", "images文件夹存放公共图片。", "Mock文件夹存放使用MockJS模拟后端接口的类。", "models文件夹存放封装好的请求类。", "utils文件夹存放公共类。", "接下来我以首页为例进行分析，其他页面也都类似。", "建议能力较强的小伙伴先把 ", "项目", " 下载下来，自己先尝试着根据效果图实现代码，做完之后再回来看与我的思路有哪些不同。", "2 起步", "2.1 布局与样式", "这个页面中每一条记录都是相同的，所以可以抽象为一个组件，在components文件夹下面创建一个组件，wxml与wxss比较简单，不做过多讲解。", "//wxml\r\n", "<", "view", " ", "class", "=", "\"container-item\"", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"item-title\"", ">", "\r\n        ", "<", "text", ">", "{{items.title}}", "</", "text", ">", "\r\n        ", "<", "image", " ", "src", "=", "\"./images/more.png\"", ">", "</", "image", ">", "\r\n    ", "</", "view", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"item-author\"", ">", "\r\n        ", "<", "image", " ", "src", "=", "\"", "{{items.imgUrl}}", "\"", ">", "</", "image", ">", "\r\n        ", "<", "text", ">", "{{items.author}}", "</", "text", ">", "\r\n    ", "</", "view", ">", "\r\n    ", "<", "text", " ", "class", "=", "\"text-body\"", ">", "{{items.content}}", "</", "text", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"item-action\"", ">", "\r\n        ", "<", "text", ">", "{{items.starNum}}", "</", "text", ">", "\r\n        ", "<", "text", ">", "赞同", "</", "text", ">", "\r\n        ", "<", "text", ">", "{{items.reviewNum}}", "</", "text", ">", "\r\n        ", "<", "text", ">", "评论", "</", "text", ">", "\r\n    ", "</", "view", ">", "\r\n", "</", "view", ">", "\r\n//部分scss\r\n$border-color:#dfdfdf;\r\n.container-item {\r\n  padding:10rpx;\r\n  display: flex;\r\n  flex-direction: column;\r\n  width: 100%;\r\n  background-color: #fff;\r\n  margin-top: 10rpx;\r\n  border-top: 1px solid $border-color;\r\n  border-bottom: 1px solid $border-color;\r\n}\r\n复制代码", "2.2 子组件与父组件的粒度大小", "子组件需要监听两个事件，分别为触摸该子组件时跳转到该问题的回答的详情页面以及触摸右上角的三个点跳转到该问题的详情页面。第二个事件触发的同时会冒泡并触发第一个事件，所以监听第二个事件的时候需要采用catch前缀监听并阻止事件冒泡。完整代码如下。", "<", "view", " ", "class", "=", "\"container-item\"", " ", "bind:tap", "=", "\"clickItems\"", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"item-title\"", ">", "\r\n        ", "<", "text", ">", "{{items.title}", "}", "</", "text", ">", "\r\n        ", "<", "image", " ", "src", "=", "\"./images/more.png\"", " ", "catch:tap", "=", "\"clickMore\"", ">", "</", "image", ">", "\r\n    ", "</", "view", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"item-author\"", ">", "\r\n        ", "<", "image", " ", "src", "=", "\"", "{{items.imgUrl}", "}\"", ">", "</", "image", ">", "\r\n        ", "<", "text", ">", "{{items.author}", "}", "</", "text", ">", "\r\n    ", "</", "view", ">", "\r\n    ", "<", "text", " ", "class", "=", "\"text-body\"", ">", "{{items.content}", "}", "</", "text", ">", "\r\n    ", "<", "view", " ", "class", "=", "\"item-action\"", ">", "\r\n        ", "<", "text", ">", "{{items.starNum}", "}", "</", "text", ">", "\r\n        ", "<", "text", ">", "赞同", "</", "text", ">", "\r\n        ", "<", "text", ">", "{{items.reviewNum}", "}", "</", "text", ">", "\r\n        ", "<", "text", ">", "评论", "</", "text", ">", "\r\n    ", "</", "view", ">", "\r\n", "</", "view", ">", "\r\n复制代码", "抽象出子组件并不难，难的是如何设计子组件与父组件的粒度大小，在上面的例子中子组件监听了触摸事件，这时候是由子组件执行wx.navigateTe()还是由父组件执行，这才是我们最需要考虑的问题，我的想法是子组件只控制样式的变化，不执行业务逻辑，业务逻辑我一律交给父组件来做。", "下面代码参考 ", "微信小程序实战教程——1基础知识 5.2.2", "//子组件中将index传给父组件，让父组件执行业务逻辑", "\r\nmethods: {\r\n    ", "//打开回答详情", "\r\n    clickItems() {\r\n      ", "let", " index=", "this", ".properties.index;\r\n      ", "this", ".triggerEvent(", "'clickItems'", ",{index});\r\n    },\r\n    ", "//打开问题详情", "\r\n    clickMore() {\r\n      ", "let", " index=", "this", ".properties.index;\r\n      ", "this", ".triggerEvent(", "'clickMore'", ",{index});\r\n    }\r\n}\r\n", "//父组件中监听子组件准备触发的事件并执行业务逻辑", "\r\n", "//wxml", "\r\n<view ", "class", "=", "\"container\"", ">\r\n    <block wx:", "for", "=", "\"{{items}}\"", " wx:", "for", "-item=", "\"v\"", " wx:", "for", "-index=", "\"i\"", ">\r\n        <index-items items=", "\"{{v}}\"", " index=", "\"{{i}}\"", " bind:clickItems=", "\"clickItems\"", " bind:clickMore=", "\"clickMore\"", "></index-items>\r\n    </block>\r\n</view>\r\n", "//js", "\r\n", "//点击回答打开详情", "\r\nclickItems(", "event", ") {\r\n    ", "//取出子组件传来的index，表示被点击的子组件的下标", "\r\n    ", "let", " index=", "event", ".detail.index;\r\n    ", "let", " id=", "this", ".data.items[index].id;\r\n    wx.navigateTo({\r\n      url: ", "'/pages/detail/detail?id='", "+id\r\n    });\r\n},\r\n", "//点击打开问题详情", "\r\nclickMore(", "event", ") {\r\n    ", "let", " index=", "event", ".detail.index;\r\n    ", "let", " id=", "this", ".data.items[index].id;\r\n    wx.navigateTo({\r\n      url:", "\"/pages/problem/problem?id=\"", "+id\r\n    });\r\n}\r\n复制代码", "2.3利用Mock制作虚拟数据", "分析首页可以得知，每条记录需要一个id、标题、作者头像、作者名、正文内容、点赞的数量以及回复的数量。", "在Mock文件夹下创建一个indexMock.js文件专门为首页提供虚拟数据。", "//indexMock.js", "\r\n", "let", " Mock = ", "require", "(", "'./mock-min.js'", ");", "//引入Mock", "\r\n", "const", " Random = Mock.Random;\r\n", "class", " ", "IndexMock", " ", "{\r\n    ", "constructor", "() {}\r\n    ", "//返回首页记录模拟数据", "\r\n    getIndexList() {\r\n        ", "return", " Mock.mock({\r\n            ", "'status'", ": ", "'0'", ",\r\n            ", "'msg'", ": ", "''", ",\r\n            ", "'data|10'", ": [{\r\n                ", "'id'", ": ", "'@guid()'", ",   ", "//id", "\r\n                ", "'img'", ": Random.img(", "'16x16'", ", ", "'#4A7BF7'", ",", "'#000'", ",", "'@word(1,2)'", "),   ", "//头像", "\r\n                ", "'title'", ": ", "'@ctitle(1,8)'", ",                    ", "//标题", "\r\n                ", "'author'", ":", "'@word(1,8)'", ",                     ", "//作者", "\r\n                ", "'content'", ":", "'@cparagraph(1)'", ",                 ", "//正文", "\r\n                ", "'star_num'", ": ", "'@integer(0,10000)'", ",            ", "//点赞数量", "\r\n                ", "'review_num'", ":", "'@integer(0,1000)'", "            ", "//回复数量", "\r\n            }]\r\n        });\r\n    }\r\n}\r\n", "export", " { IndexMock };\r\n复制代码", "2.4 封装AJAX请求", "微信小程序提供了wx.request()接口发送网络请求，这是十分常用的API，封装后我们可以省去很多的代码量。", "//不封装直接使用我们发送一个AJAX请求需要大量代码", "\r\n", "wx", ".request", "({\r\n    ", "url", ":", "\"\"", ",\r\n    ", "data", ":", "\"数据\"", ",\r\n    ", "method", ":", "\"请求方式\"", "， ", "//有GET、POST、PUT等值", "\r\n    ", "dataType", ":", "\"返回数据类型\"", ",", "//默认为json字符串", "\r\n    ", "header", ":{\r\n        ", "//请求头    ", "\r\n    },\r\n    ", "success", "() {\r\n        ", "//接口调用成功的回调函数", "\r\n    },\r\n    fail() {\r\n        ", "//接口调用失败的回调函数", "\r\n    },\r\n    complete() {\r\n        ", "//接口调用成功/失败都会执行的回调函数", "\r\n    }\r\n});\r\n复制代码", "在utils文件夹中创建一个HTTP.js文件，在这里对wx.request进行一次封装", "class", " ", "HTTP", " {\r\n    constructor() {}\r\n    request(", "params", ") {\r\n        ", "//默认值处理,url不允许为空", "\r\n        ", "if", "(!", "params", ".url) {\r\n            console.log(", "'url没有传入'", ");\r\n            ", "return", ";\r\n        }\r\n        ", "//method默认为GET", "\r\n        ", "if", "(!", "params", ".method) {\r\n            ", "params", ".method=", "'GET'", ";\r\n        }\r\n        wx.request({\r\n            url:", "params", ".url,\r\n            method:", "params", ".method,\r\n            data:", "params", ".data,\r\n            header:{\r\n                ", "'content-type'", ":", "'application/json'", "\r\n            },\r\n            success:res=> {\r\n                ", "let", " code=res.statusCode.toString().substr(", "0", ",", "1", ");\r\n                ", "//http请求状态码为2开头的时候判断为请求成功", "\r\n                ", "if", "(code===", "'2'", ") {\r\n                    ", "params", ".success && ", "params", ".success(res.data);\r\n                }\r\n                ", "//状态码不为2开头如5开头的则判断为请求失败", "\r\n                ", "else", " {\r\n                    ", "params", ".error && ", "params", ".error(res.data);\r\n                }\r\n            },\r\n            fail:()=> {\r\n                console.log(", "'ajax error'", ");\r\n            }\r\n        });\r\n    }\r\n};\r\nexport {HTTP};\r\n复制代码", "现在我们发送一个AJAX只需要传入url、data、method为GET时可以省略、success方法以及error方法。仍然需要传入很多参数，这时候可以对每一个具体的AJAX请求做一个封装。", "在models文件夹中创建首页发送AJAX的文件indexModels.js，在这其中对首页使用到的AJAX请求进行第二次封装。", "import", " {", "HTTP", "} from '../utils/", "HTTP", ".js';\r\n", "import", " {", "IndexMock", "} from '../", "Mock", "/indexMock.js' ;\r\nlet indexMock=", "new", " ", "IndexMock", "();\r\n", "class", " ", "IndexModels", " ", "extends", " ", "HTTP", "{\r\n    constructor (){\r\n        ", "super", "();\r\n    }\r\n    ", "//请求首页真实数据", "\r\n    getIndexList(data,success) {\r\n        let params={\r\n            url:", "'http", ":", "//xxx.com/Index/List',", "\r\n            ", "//请求数据使用GET请求，method不需要设置", "\r\n            data:data,\r\n            success:success\r\n        };\r\n        ", "this", ".request(params);\r\n    }\r\n    ", "//请求首页模拟数据", "\r\n    getIndexListByMock(data,success) {\r\n        let list=indexMock.getIndexList();\r\n        success && success(list);\r\n    }\r\n}\r\nexport {", "IndexModels", "};\r\n复制代码", "在页面中引入indexModels.js文件后new一个类即可调用getIndexListByMock方法，此时只需要传入data与success方法。", "2.5 简化Mock的副作用", "使用Mock之后总是要切换回真实数据的，这时候在页面中的每一个AJAX请求都需要更改，太过繁琐，这时可以考虑引入一个全局常量，只修改这个常量即可实现Mock数据切换为真实数据。", "在最外层创建一个config.js文件，定义一个常量用于控制数据来源是Mock数据还是真实数据。", "const", " DEBUGGER=", "true", ";\r\n", "export", " {DEBUGGER};\r\n复制代码", "在indexModels.js文件中引入config.js，使用常量DEBUGGER来判断使用哪个来源的数据，indexModels.js改变为：", "//DEBUGGER为true表示请求虚拟数据，为false表示请求真实数据", "\r\n", "import", " {DEBUGGER} ", "from", " ", "'../config.js'", ";\r\n", "import", " {HTTP} ", "from", " ", "'../utils/HTTP.js'", ";\r\n", "import", " {IndexMock} ", "from", " ", "'../Mock/indexMock.js'", " ;\r\n", "let", " indexMock=", "new", " IndexMock();\r\n", "class", " ", "IndexModels", " ", "extends", " ", "HTTP", "{\r\n    ", "constructor", " (){\r\n        ", "super", "();\r\n    }\r\n    ", "//请求首页数据", "\r\n    getIndexList(data,success) {\r\n        ", "if", "(!DEBUGGER) {", "//请求真实数据", "\r\n            ", "let", " params={\r\n                ", "url", ":", "'http://xxx.com/Index/List'", ",\r\n                ", "data", ":data,\r\n                ", "success", ":success\r\n            };\r\n            ", "this", ".request(params);\r\n        }\r\n        ", "else", " {", "//请求虚拟数据", "\r\n            ", "let", " list=indexMock.getIndexList();\r\n            success && success(list);\r\n        }\r\n    }\r\n}\r\n", "export", " {IndexModels};\r\n复制代码", "之后需要改变数据来源为真实数据时，只需要在config.js中将DEBUGGER改变为false即可。至此，这个页面就已经写完了。", " "]}
{"title": "如何两步完成一个抽奖小程序 ", "author": "Rolan", "pub_time": "2019-7-4 00:49", "content": [" \n                     \n                    ", "前言", "\r\n", "这是一个简单的抽奖+闹钟", "小程序", "，起源于本人不想去上课又觉得心里有愧(大学生懂得都懂)，干脆做一个抽奖系统，让系统帮我决定是否去上课", "\r\n", "\r\n", "作者是一名在校大学生兼前端小白，刚开始学习前端，这个小程序算是一个巩固练手项目吧，若文章中有错误的地方欢迎指正", "\r\n", "\r\n", "描述", "\r\n", "我的想法是把页面分为首页和闹钟页，首页实现点击按钮随机抽取一个选项 根据所选中的选项弹出相应的提示框，若选中的选项为时间，则跳转到闹钟页，闹钟页开始倒计时，时间到了之后播放闹铃并弹出提示框，下面让我们开始吧", "\r\n", "第一步", "\r\n", "页面", "\r\n", "页面方面比较简单，首页就是把九张图片以九宫格的形式放置，这里直接贴上代码", "\r\n", "index.html", "\r\n", "<", "view", " ", "class", "=", "\"container\"", ">", "\r\n  ", "<", "view", " ", "class", "=", "'frame_view'", ">", "\r\n    ", "<", "view", " ", "class", "=", "'frame_row'", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "style", "=", "'opacity:{{color[0]}}'", " ", "src", "=", "'{{images[0]}}'", ">", "</", "image", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "style", "=", "'opacity:{{color[1]}}'", " ", "src", "=", "'{{images[1]}}'", ">", "</", "image", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "style", "=", "'opacity:{{color[2]}}'", " ", "src", "=", "'{{images[2]}}'", ">", "</", "image", ">", "\r\n    ", "</", "view", ">", "\r\n    ", "<", "view", " ", "class", "=", "'frame_row'", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "style", "=", "'opacity:{{color[7]}}'", " ", "src", "=", "'{{images[7]}}'", ">", "</", "image", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "src", "=", "'{{btnconfirm}}'", " ", "bindtap", "=", "'{{clickLuck}}'", ">", "</", "image", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "style", "=", "'opacity:{{color[3]}}'", " ", "src", "=", "'{{images[3]}}'", ">", "</", "image", ">", "\r\n    ", "</", "view", ">", "\r\n    ", "<", "view", " ", "class", "=", "'frame_row'", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "style", "=", "'opacity:{{color[6]}}'", " ", "src", "=", "'{{images[6]}}'", ">", "</", "image", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "style", "=", "'opacity:{{color[5]}}'", " ", "src", "=", "'{{images[5]}}'", ">", "</", "image", ">", "\r\n      ", "<", "image", " ", "class", "=", "'frame_item'", " ", "style", "=", "'opacity:{{color[4]}}'", " ", "src", "=", "'{{images[4]}}'", ">", "</", "image", ">", "\r\n    ", "</", "view", ">", "\r\n  ", "</", "view", ">", "\r\n", "</", "view", ">", "\r\n", "复制代码", "这时我们的页面应该是这样的", "\r\n", "\r\n", "\r\n", "闪电代表的是立即去上课， 微笑代表的是不去上课，Iconfont里找的图属实有点抽象 ", "\r\n", "\r\n", "\r\n", "值得注意的是这里把图片的透明度和地址都放在了一个数组里，方便后面实现轮播的功能，初始数据为", "\r\n", "\r\n", "data: {\r\n    ", "color", ": [", "0.5", ",", "0.5", ",", "0.5", ",", "0.5", ",", "0.5", ",", "0.5", ",", "0.5", ",", "0.5", "],\r\n    ", "images", ": [", "'/images/likequ.png'", ", ", "'/images/fiveminutes.png'", ", ", "'/images/thirtyminutes.png'", ", ", "'/images/likequ.png'", ", ", "'/images/onehour.png'", ", ", "'/images/fiveminutes.png'", ", ", "'/images/likequ.png'", ", ", "'/images/buqu.png'", "],\r\n    ", "btnconfirm", ": ", "'/images/dianjichoujiang.png'", ",\r\n    ", "clickLuck", ": ", "'clickLuck'", ",\r\n    ", "luckPosition", ": ", "0", "\r\n  },\r\n", "复制代码", "第二步", "\r\n", "开始抽奖", "\r\n", "\r\n", "在此之前先在app.js中定义全局变量", "\r\n", "\r\n", "globalData: {\r\n  ", "number", ": ", "0", ",\r\n  ", "numbers", ": ", "0", ",\r\n  ", "remainTime", ": ", "0", "\r\n}\r\n", "复制代码", "点击开始抽奖之后设置按钮为不可点击，并生成一个1-7的随机数，根据生成的随机数改变图片的透明度实现抽中效果，之后把全局变量传给闹钟页面", "\r\n", "index.js", "\r\n", "clickLuck() {\r\n    ", "let", " self = ", "this", "\r\n    self.setData({\r\n      ", "btnconfirm", ": ", "'/images/bunengdianji.png'", ",\r\n      ", "clickLuck", ": ", "''", ",\r\n      ", "luckPosition", ": ", "parseInt", "(", "Math", ".random()*", "8", ")\r\n    })\r\n\r\n    clearInterval(interval)\r\n    ", "let", " index = ", "0", "\r\n    interval = setInterval(", "()", " =>", " {\r\n      ", "if", " (index > ", "7", ") {\r\n        index = ", "0", "\r\n        self.data.color[", "7", "] = ", "0.5", "\r\n      } ", "else", " ", "if", " (index !=", "0", ") {\r\n        self.data.color[index", "-1", "] = ", "0.5", "\r\n      }\r\n      self.data.color[index] = ", "1", "\r\n      self.setData({\r\n        ", "color", ": self.data.color\r\n      })\r\n      index++\r\n    },intime)\r\n    setTimeout(", "()", " =>", " {\r\n      self.stop(self.data.luckPosition)\r\n    },", "2000", ")\r\n  },\r\n  stop(which) {\r\n    ", "let", " self = ", "this", "\r\n    clearInterval(interval)\r\n    ", "let", " current = ", "-1", "\r\n    ", "let", " color = self.data.color\r\n    ", "for", "(", "let", " i=", "0", ";i<color.length;i++) {\r\n      ", "if", "(color[i] == ", "1", ") {\r\n        current = i\r\n      }\r\n    }\r\n    ", "let", " index = current + ", "1", "\r\n    self.stopLuck(which, index, intime, ", "10", ")\r\n  },\r\n  stopLuck(which, index, time, splittime) {\r\n    ", "let", " self = ", "this", "\r\n    ", "let", " color = self.data.color\r\n    setTimeout(", "()", " =>", " {\r\n      ", "if", "(index > ", "7", ") {\r\n        index = ", "0", "\r\n        color[", "7", "] = ", "0.5", "\r\n      } ", "else", " ", "if", " (index != ", "0", ") {\r\n        color[index - ", "1", "] = ", "0.5", "\r\n      }\r\n      color[index] = ", "1", "\r\n      self.setData({\r\n        color\r\n      })\r\n      ", "if", " (time < ", "400", " || index != which) {\r\n        splittime++\r\n        time +=splittime\r\n        index++\r\n        self.stopLuck(which, index, time, splittime)\r\n      } ", "else", " {\r\n        setTimeout(", "()", " =>", " {\r\n          ", "if", " (which == ", "0", " || which == ", "3", " || which == ", "6", ") {\r\n            wx.showModal({\r\n              ", "title", ": ", "'提示'", ",\r\n              ", "content", ": ", "'别偷懒，立刻去上课'", ",\r\n              ", "showCancel", ": ", "false", ",\r\n              success(res) {\r\n                self.setData({\r\n                  ", "btnconfirm", ": ", "'/images/dianjichoujiang.png'", ",\r\n                  ", "clickLuck", ": ", "'clickLuck'", "\r\n                })\r\n                self.loadAnimation()\r\n              }\r\n            })\r\n          } ", "else", " ", "if", " (which == ", "1", " || which == ", "5", ") {\r\n            wx.showModal({\r\n              ", "title", ": ", "'提示'", ",\r\n              ", "content", ": ", "'五分钟后再去上课，点击确定开始计时'", ",\r\n              ", "showCancel", ": ", "false", ",\r\n              success(res) {\r\n                wx.switchTab({\r\n                  ", "url", ":", "\"/pages/clock/clock\"", ",\r\n                  ", "success", ": ", "function", "(", "res", ") ", "{\r\n                    getApp().globalData.number = ", "1", ";\r\n                    getApp().globalData.numbers = ", "1", ";\r\n                    getApp().globalData.remainTime = ", "300000", ";\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } ", "else", " ", "if", " (which == ", "2", ") {\r\n            wx.showModal({\r\n              ", "title", ": ", "'提示'", ",\r\n              ", "content", ": ", "'三十分钟后再去上课，点击确定开始计时'", ",\r\n              ", "showCancel", ": ", "false", ",\r\n              success(res) {\r\n                wx.switchTab({\r\n                  ", "url", ":", "\"/pages/clock/clock\"", ",\r\n                  ", "success", ": ", "function", "(", "res", ") ", "{\r\n                    getApp().globalData.number = ", "2", ";\r\n                    getApp().globalData.numbers = ", "2", ";\r\n                    getApp().globalData.remainTime = ", "1800000", ";\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } ", "else", " ", "if", " (which == ", "4", ") {\r\n            wx.showModal({\r\n              ", "title", ": ", "'提示'", ",\r\n              ", "content", ": ", "'一小时后再去上课，点击确定开始计时'", ",\r\n              ", "showCancel", ": ", "false", ",\r\n              success(res) {\r\n                wx.switchTab({\r\n                  ", "url", ":", "\"/pages/clock/clock\"", ",\r\n                  ", "success", ": ", "function", "(", "res", ") ", "{\r\n                    getApp().globalData.number = ", "3", ";\r\n                    getApp().globalData.numbers = ", "3", ";\r\n                    getApp().globalData.remainTime = ", "3600000", ";\r\n                  }\r\n                })\r\n              }\r\n            })\r\n          } ", "else", " {\r\n            wx.showModal({\r\n              ", "title", ": ", "'提示'", ",\r\n              ", "content", ": ", "'今天有点累，就不去上课了吧'", ",\r\n              ", "showCancel", ": ", "false", ",\r\n              success(res) {\r\n                self.setData({\r\n                  ", "btnconfirm", ": ", "'/images/dianjichoujiang.png'", ",\r\n                  ", "clickLuck", ": ", "'clickLuck'", ",\r\n                })\r\n                self.loadAnimation()\r\n              }\r\n            })\r\n          }\r\n        },", "1000", ")\r\n      }\r\n    },time)\r\n  },\r\n", "复制代码", "现在一个简单的抽奖功能已经完成了，让我们看下效果", "\r\n", "\r\n", "轮播", "\r\n", "\r\n接下来让我们实现一下轮播的效果，就像小时候玩的老虎机一样，当没有人在玩的时候，它会自动转动\r\n", "loadAnimation() {\r\n    ", "let", " self = ", "this", "\r\n    ", "let", " index = ", "0", "\r\n    interval = setInterval(", "()", " =>", " {\r\n      ", "if", " (index > ", "7", ") {\r\n        index = ", "0", "\r\n        self.data.color[", "7", "] = ", "0.5", "\r\n      } ", "else", " ", "if", " (index !=", "0", ") {\r\n        self.data.color[index", "-1", "] = ", "0.5", "\r\n      }\r\n      self.data.color[index] = ", "1", "\r\n      self.setData({\r\n        ", "color", ": self.data.color\r\n      })\r\n      index++\r\n    },", "100", ")\r\n  }\r\n", "复制代码", "把它放入onLoad生命周期中，这样抽奖页面就完成了", "\r\n", "闹钟页面", "\r\n", "clock.html", "\r\n", "<", "view", " ", "class", "=", "\"container\"", ">", "\r\n\t\t", "<", "view", " ", "class", "=", "\"clock\"", ">", "\r\n\t\t\t", "<", "view", ">", "{{listData[0].countDown}}", "</", "view", ">", "\r\n\t\t", "</", "view", ">", "\r\n\t\t", "<", "view", " ", "wx:if", "=", "\"{{number == 0}}\"", ">", "\r\n\t\t\t", "<", "botton", " ", "class", "=", "\"btn\"", " ", "loading", "=", "\"{{loading}}\"", " ", "disabled", "=", "\"{{disabled}}\"", " ", "bindtap", "=", "\"primary\"", ">", "点击抽奖", "</", "botton", ">", "\r\n\t\t", "</", "view", ">", "\r\n\t\t", "<", "view", " ", "wx:if", "=", "\"{{number != 0}}\"", ">", "\r\n\t\t\t", "<", "botton", " ", "class", "=", "\"btn\"", " ", "loading", "=", "\"{{loading}}\"", " ", "disabled", "=", "\"{{disabled}}\"", " ", "bindtap", "=", "\"primary_fq\"", ">", "放弃计时", "</", "botton", ">", "\r\n\t\t", "</", "view", ">", "\r\n", "</", "view", ">", "\r\n", "复制代码", "初始数据为", "\r\n", "data: {\r\n    ", "number", ": ", "0", ",\r\n    ", "numbers", ": ", "0", ",\r\n    ", "listData", ": [\r\n      {\r\n        ", "id", ": ", "0", ",\r\n        ", "remainTime", ": ", "0", "\r\n      }\r\n    ]\r\n  },\r\n", "复制代码", "倒计时", "\r\n", "这里的思路是根据首页传回来的数据用定时器对数组进行减少处理", "\r\n", "setCountDown () {\r\n    ", "let", " time = ", "1000", ";\r\n    ", "let", " { listData } = ", "this", ".data;\r\n    ", "let", " list = listData.map(", "(", "e", ") =>", "{\r\n      ", "if", " (e.remainTime <= ", "0", ") {\r\n          e.remainTime = ", "0", ";\r\n      }\r\n      ", "let", " formatTime = ", "this", ".getFormat(e.remainTime);\r\n      e.remainTime -= time;\r\n      e.countDown = ", "`", "${formatTime.mm}", ":", "${formatTime.ss}", "`", ";\r\n      ", "if", " (e.remainTime == ", "0", ") {\r\n        wx.playBackgroundAudio({\r\n          ", "dataUrl", ": ", "'/images/naozhong.mp3'", ",\r\n          ", "title", ": ", "'闹钟'", ",\r\n          ", "coverImgUrl", ": ", "''", "\r\n        })\r\n        wx.showModal({\r\n          ", "title", ": ", "'提示'", ",\r\n          ", "content", ": ", "'时间到啦!'", ",\r\n          ", "showCancel", ": ", "false", ",\r\n          success(res) {\r\n            wx.pauseBackgroundAudio()\r\n          }\r\n        })\r\n      }\r\n      ", "return", " e;\r\n    })\r\n    ", "this", ".setData({\r\n        ", "listData", ": list\r\n    });\r\n    setTimeout(", "this", ".setCountDown, time);\r\n  },\r\n", "复制代码", "\r\n", "getFormat()是一个格式化时间的函数", "\r\n", "\r\n", "getFormat (msec) {\r\n    ", "let", " ss = ", "parseInt", "(msec / ", "1000", ");\r\n    ", "let", " ms = ", "parseInt", "(msec % ", "1000", ");\r\n    ", "let", " mm = ", "0", ";\r\n    ", "let", " hh = ", "0", ";\r\n    ", "if", " (ss > ", "60", ") {\r\n      mm = ", "parseInt", "(ss / ", "60", ");\r\n      ss = ", "parseInt", "(ss % ", "60", ");\r\n      ", "if", " (mm > ", "60", ") {\r\n        hh = ", "parseInt", "(mm / ", "60", ");\r\n        mm = ", "parseInt", "(mm % ", "60", ");\r\n      }\r\n    }\r\n    ss = ss > ", "9", " ? ss : ", "`0", "${ss}", "`", ";\r\n    mm = mm > ", "9", " ? mm : ", "`0", "${mm}", "`", ";\r\n    hh = hh > ", "9", " ? hh : ", "`0", "${hh}", "`", ";\r\n    ", "return", " { ms, ss, mm, hh };\r\n  }\r\n})\r\n", "复制代码", "完整效果图", "\r\n", "\r\n", "当时间到了的时候", "\r\n", "\r\n", "总结", "\r\n", "这只是我临时兴起的一个小项目，如果你觉得还不错，不妨给个赞鼓励下，您的鼓励是我前进的动力。", "\r\n最后奉上", "源码", "。", " "]}
{"title": "微信小程序全局变量改变监听 ", "author": "Rolan", "pub_time": "2019-7-15 00:58", "content": [" \n                     \n                    ", "问题来源", "最近工作需要写", "小程序", "页面，其中有个页面情况为：", "父页面中包含了一个组件页面，组件页面中又包含了另外一个组件页面", "。需求为：", "点击最后一个组件页面中的一个view，需要显示最外层父页面中的一个弹出层，并且动态的展示值，这个值的来源就是最后一个组件页面中的内容", "。", "处理办法", "当时想到的就是使用全局变量，在 app.js 中定义好全局变量，点击组件页面时就修改全局变量的值，父页面同样使用全局变量的值，这样一来就可以动态打开/关闭弹出层且传递值了。", "下面先看看 app.js 中怎么定义的：", "globalData: {\r\n    openid: ", "''", ",\r\n    userInfo: ", "null", ",\r\n    _showPictureDetail: ", "false", ",\r\n    _pictureTime: ", "''", ",\r\n    _pictureAddress: ", "''", ",\r\n    ", "//", "改变量用户存放全局变量修改过程中的值传递, 传递对象", "\r\n", "    data: {}\r\n  }", "在其他页面就使用 getApp().globalData.参数名 = 值 的形式来改变参数值， 使用 getApp().globalData.参数名 的形式来获取值。", "这样能正常赋值，但是由于都是在同一个界面展示，我需要更新值后，马上得到最新的值。上面简单的设置获取就不起作用了。", "那么，就需要监听 globalData 中的属性了。", "首先是 app.js：", "//", "app 全局属性监听", "\r\n  watch: ", "function", " (method) {\r\n    ", "var", " obj = ", "this", ".globalData;\r\n    ", "Object.defineProperty", "(obj, ", "\"data\"", ", { ", " //这里的 data 对应 上面 globalData 中的 data", "\r\n      configurable: ", "true", ",\r\n      enumerable: ", "true", ",\r\n      set: ", "function", " (value) {  ", "//动态赋值，传递对象，为 globalData 中对应变量赋值\r\n        ", "this", "._showPictureDetail =", " value.showPictureDetail;\r\n        ", "this", "._pictureTime =", " value.pictureTime;\r\n        ", "this", "._pictureAddress =", " value.pictureAddress;\r\n        method(value);\r\n      },\r\n      get: ", "function", " () {  ", "//获取全局变量值，直接返回全部\r\n        ", "return", " ", "this", ".globalData;\r\n      }\r\n    })\r\n  },", "接下来就是在组件页面事件中动态赋值：", "//", "图片拍摄详情查看", "\r\n    viewPictureDetailInfo: ", "function", " (e) {\r\n      ", "//", " 修改 app 全局属性值， ", "由于 globalData.data 是个对象，因为涉及到修改多个参数，所以需要传递对象", "\r\n      app.globalData.data =", " {\r\n        ", "'_showPictureDetail': ", "true", ",\r\n        ", "'_pictureTime'", ": e.currentTarget.dataset.phototime,\r\n        ", "'_pictureAddress'", ": e.currentTarget.dataset.address\r\n      }\r\n    },", "最后就是在最外层父页面添加 app.js 监听回调，动态修改变量值，以达到动态打开/关闭弹出层和展示内容了：", "//", " 首先需要在父页面 onLoad() 方法中添加监听以及指定监听回调方法", "\r\n//", " 设置 App 监听回调", "\r\n//", " 如果其他页面修改了 app.js 中的 showPictureDetail 值, 就会触发回调", "\r\n", "getApp().watch(self.watchBack)\r\n\r\n", "//", "定义监听回调方法", "\r\n//", "app 监听回调方法", "\r\n  watchBack: ", "function", " (value) {  ", "//这里的value 就是 app.js 中 watch 方法中的 set, 返回整个 globalData\r\n    ", "this", ".setData({\r\n      showPictureDetail: value._showPictureDetail,\r\n      pictureTime: value._pictureTime,\r\n      pictureAddress: value._pictureAddress\r\n    });\r\n  },", "这样，在父页面中使用 showPictureDetail..这几个变量就可以动态展示了。", "PS：我这边的业务需求涉及到多个变量的监听，如果你只有一个变量的监听，那么只需要修改 app.js 中 watch 方法的 Object.defineProperty 内容由对象传递变为单个值传递即可。在更新值和获取值时传递就是一个值，而不是对象。", " "]}
{"title": "微信小程序支付功能全流程实践 ", "author": "Rolan", "pub_time": "2019-7-16 00:31", "content": [" \n                     \n                    ", "前言", "微信", "小程序", "为电商类小程序，提供了非常完善、优秀、安全的支付功能。在小程序内可调用微信的API完成支付功能，方便、快捷。小程序开发者在开发小程序时，支付流程是必然要接触到，今天胡哥就小程序支付的全流程为大家一一细说，让小伙伴能快速得掌握小程序支付能力，避免踩坑！", "知己知彼，方能百战不殆 - 小程序支付流程图", "举个栗子:chestnut:：", "某用户小明在某电商小程序上购买一块肥皂，从浏览、下单到支付经历了什么样的过程呢？", "打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单", "wx.login获取用户临时登录凭证code，发送到后端服务器换取openId", "在下单时，小程序需要将小明购买的商品Id，商品数量，以及小明这个用户的openId传送到服务器", "服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)", "小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付", "小结", "进行微信支付，在小程序端我们主要做三件事：", "注：服务端调用统一下单API、签名算法不再本次分享讨论范围内，请期待胡哥的另外一次分享。", "使用 ", "wx.login", " ", "获取临时登录凭证code,发送到后端获取openId", "wx", ".login", "({\r\n  ", "success", " (res) {\r\n    ", "if", " (res.code) {\r\n      ", "// 发起请求，换取openId", "\r\n      ", "wx", ".request", "({\r\n        ", "url", ": ", "''", ",\r\n        ", "data", ": {\r\n          ", "code", ": res.code\r\n        }\r\n      })\r\n    }\r\n  }\r\n})", "将 ", "openId", " ", "以及相应需要的商品信息发送到后端，换取服务端进行的签名等信息", "wx", ".request", "({\r\n  ", "url", ": ", "''", ",\r\n  ", "data", ": {\r\n    ", "openId", ": ", "''", ",\r\n    ", "num", ": ", "1", ",\r\n    ", "id", ": ", "'111'", "\r\n  }\r\n})", "接收返回的信息（必须要包含发起微信支付 ", "wx.requestPayment的参数", " ", "），发起微信支付", "wx", ".requestPayment", "({\r\n  ", "// 时间戳", "\r\n  ", "timeStamp", ": ", "''", ",\r\n  ", "// 随机字符串", "\r\n  ", "nonceStr", ": ", "''", ",\r\n  ", "// 统一下单接口返回的 prepay_id 参数值", "\r\n  ", "package", ": ", "''", ",\r\n  ", "// 签名类型", "\r\n  ", "signType", ": ", "''", ",\r\n  ", "// 签名", "\r\n  ", "paySign", ": ", "''", ",\r\n  ", "// 调用成功回调", "\r\n  success () {},\r\n  ", "// 失败回调", "\r\n  ", "fail", " () {},\r\n  ", "// 接口调用结束回调", "\r\n  complete () {}\r\n})", "注意：以上信息中 ", "timeStamp", " 、 ", "nonceStr", " 、 ", "prepay_id", " 、 ", "signType", " 、 ", "paySign", " 各参数均建议必须都由服务端返回（这样会尽最大可能性保证签名数据一致性），小程序端不做任何处理", "基于Taro的微信支付实例", "import", " Taro, { Component } ", "from", " ", "'@tarojs/taro'", "\r\n", "import", " { View, Text, Button } ", "from", " ", "'@tarojs/components'", "\r\n", "import", " ", "'./index.scss'", "\r\n\r\n", "export", " ", "default", " ", "class", " ", "Index", " ", "extends", " ", "Component", " ", "{\r\n\r\n  config = {\r\n    ", "navigationBarTitleText", ": ", "'首页'", "\r\n  }\r\n\r\n  componentWillMount () { }\r\n\r\n  ", "async", " componentDidMount () { \r\n  }\r\n\r\n  componentWillUnmount () { }\r\n\r\n  componentDidShow () { }\r\n\r\n  componentDidHide () { }\r\n\r\n  ", "/**\r\n   * sendOrderInfo()\r\n   * @description 提交订单信息，获取支付凭证，唤起支付\r\n   */", "\r\n  ", "async", " sendOrderInfo () {\r\n    ", "// 获取临时登录凭证code", "\r\n    ", "let", " codeData = ", "await", " Taro.login()\r\n    ", "// 换取openId", "\r\n    ", "let", " openId = ", "''", "\r\n    ", "if", " (codeData.code) {\r\n      ", "let", " res = ", "await", " Taro.request({\r\n        ", "// 定义的后端换取openId的接口", "\r\n        url: ", "'https://www.justbecoder.com/getLogin'", ",\r\n        ", "data", ": {\r\n          ", "code", ": codeData.code\r\n        }\r\n      })\r\n      ", "if", " (res && res.code === ", "0", ") {\r\n        openId = res.openId\r\n      }\r\n    }\r\n    ", "// 发送openId以及对应的商品信息", "\r\n    ", "let", " data = ", "await", " Taro.requrest({\r\n      ", "url", ": ", "'https://www.justbecoder.com/createdOrder'", ",\r\n      ", "data", ": {\r\n        openId,\r\n        ", "// 实际情况的商品数量", "\r\n        num: ", "1", ",\r\n        ", "// 实际情况的商品Id", "\r\n        id: ", "111", ",\r\n      }\r\n    })\r\n    ", "// code === 0 表示提交订单成功，返回需要的签名信息等", "\r\n    ", "if", " (data && data.code === ", "0", ") {\r\n      ", "let", " {\r\n        timeStamp,\r\n        nonceStr,\r\n        prepay_id,\r\n        signType,\r\n        paySign\r\n      } = data.payInfo\r\n      ", "// 唤起支付，按小程序要求格式发送参数", "\r\n      ", "let", " payData = ", "await", " Taro.requestPayment({\r\n        timeStamp,\r\n        nonceStr,\r\n        ", "package", ": ", "'prepay_id='", " + prepay_id,\r\n        signType,\r\n        paySign\r\n      })\r\n      ", "if", " (payData && payData.errMsg === ", "'requestPayment:ok'", ") {\r\n        Taro.showModal({\r\n          ", "title", ": ", "'操作提示'", ",\r\n          ", "content", ": ", "'支付成功'", ",\r\n          ", "showCancel", ": ", "false", ",\r\n          ", "confirmText", ": ", "'确定'", "\r\n        })\r\n      } ", "else", " {\r\n        Taro.showModal({\r\n          ", "title", ": ", "'操作提示'", ",\r\n          ", "content", ": ", "'支付失败，请重新尝试'", ",\r\n          ", "showCancel", ": ", "false", ",\r\n          ", "confirmText", ": ", "'确定'", "\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  render () {\r\n    ", "return", " (\r\n      ", "<", "View", " ", "className", "=", "'index'", ">", "\r\n        ", "<", "Button", " ", "onClick", "=", "{this.sendOrderInfo}", ">", "立即下单", "</", "Button", ">", "\r\n      ", "</", "View", ">", "\r\n    )\r\n  }\r\n}", "效果图", "结语", "在实际项目操作中，大家把接口换成自己的可用接口即可。", "后记", "以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得 ", "收藏", " ", "、 ", "转发", " ", "、点击右下角按钮 ", "在看", " ", "，推荐给更多小伙伴呦，欢迎多多留言交流...", "胡哥有话说，一个有技术，有情怀的胡哥！京东开放平台首席前端攻城狮。与你一起聊聊大前端，分享前端系统架构，框架实现原理，最新最高效的技术实践！", " "]}
{"title": "小程序使用canvas二维码保存至手机相册 ", "author": "Rolan", "pub_time": "2019-7-16 00:45", "content": [" \n                     \n                    ", "在使用canvas绘制海报的过程中不建议使用原生来进行画图，因为默认是不支持rpx像素的，px不会做到自适应。", "\r\n", "推荐使用插件 Painter", "\r\n", "github地址\r\n", "github.com/Kujiale-Mob…", "\r\n", "配置很简单，也容易上手，无论是画矩形，还是将图片合成canvas；还是自己定义文字；都是很方便的。", "\r\n", "附上一个简单的例子吧", "\r\n", "\r\n", " ", "<", "painter", " ", ":customStyle", "=", "\"customStyle\"", " ", ":palette", "=", "\"imgDraw\"", " />", "\r\n", "复制代码", "//", "\r\n  ", "const", " _this=", "this", ";\r\n      wx.getSystemInfo({\r\n        success (res) {\r\n          _this.drawCanvas(res.windowHeight);\r\n        }\r\n      })\r\n\t  \r\ndrawCanvas(height) {\r\n", "//这里的canvas的高是动态获取设备的高度，做到自适应", "\r\n       ", "const", " that = ", "this", ";\r\n      ", "let", " heightVal=height*", "2", "+", "'rpx'", ";\r\n      ", "this", ".imgDraw = {\r\n        ", "width", ": ", "'750rpx'", ",\r\n        ", "height", ": heightVal,\r\n        ", "background", ": ", "'#fff'", ",\r\n        ", "views", ": [\r\n          {\r\n            ", "type", ": ", "\"rect\"", ",\r\n            ", "css", ": {\r\n              ", "top", ": ", "'20rpx'", ",\r\n              ", "left", ": ", "'130rpx'", ",\r\n              ", "color", ": ", "'#1A1A1A'", ",\r\n              ", "width", ": ", "'660rpx'", ",\r\n              ", "height", ": ", "'220rpx'", ",\r\n              ", "borderRadius", ": ", "'32rpx'", "\r\n            }\r\n          },\r\n          {\r\n            ", "type", ": ", "'image'", ",\r\n            ", "url", ": ", "'./a.jpg'", ",\r\n            ", "css", ": {\r\n              ", "top", ": ", "'36rpx'", ",\r\n              ", "left", ": ", "'16rpx'", ",\r\n              ", "width", ": ", "'188rpx'", ",\r\n              ", "height", ": ", "'188rpx'", "\r\n            }\r\n          },\r\n          {\r\n            ", "type", ": ", "'text'", ",\r\n            ", "text", ": ", "''", ",\r\n            ", "css", ": {\r\n              ", "top", ": ", "'54rpx'", ",\r\n              ", "left", ": ", "'260rpx'", ",\r\n              ", "fontSize", ": ", "'48rpx'", ",\r\n              ", "color", ": ", "\"#fff\"", "\r\n            }\r\n          },\r\n          {\r\n            ", "type", ": ", "'text'", ",\r\n            ", "text", ": ", "'文字部分'", ",\r\n            ", "css", ": {\r\n              ", "top", ": ", "'134rpx'", ",\r\n              ", "left", ": ", "'260rpx'", ",\r\n              ", "fontSize", ": ", "'30rpx'", ",\r\n              ", "color", ": ", "\"#d1d1d1\"", "\r\n            }\r\n          },\r\n          {\r\n            ", "type", ": ", "'text'", ",\r\n            ", "text", ": ", "'1333333333'", ",\r\n            ", "css", ": {\r\n              ", "top", ": ", "'196rpx'", ",\r\n              ", "left", ": ", "'260rpx'", ",\r\n              ", "fontSize", ": ", "'26rpx'", ",\r\n              ", "color", ": ", "\"#d1d1d1\"", "\r\n            }\r\n          },\r\n          {\r\n            ", "type", ": ", "'text'", ",\r\n            ", "text", ": ", "'李四'", ",\r\n            ", "css", ": {\r\n              ", "top", ": ", "'304rpx'", ",\r\n              ", "left", ": ", "'302rpx'", ",\r\n              ", "fontSize", ": ", "'24rpx'", ",\r\n              ", "color", ": ", "\"#767676\"", "\r\n            }\r\n          },\r\n          {\r\n            ", "type", ": ", "'image'", ",\r\n            ", "url", ": ", "'/icon-localtion.png'", ",\r\n            ", "css", ": {\r\n              ", "top", ": ", "'275rpx'", ",\r\n              ", "left", ": ", "'260rpx'", ",\r\n              ", "width", ": ", "'26rpx'", ",\r\n              ", "height", ": ", "'168rpx'", "\r\n            }\r\n          },\r\n          {\r\n            ", "type", ": ", "'image'", ",\r\n            ", "url", ": ", "'二维码.png'", ",\r\n            ", "css", ": {\r\n              ", "top", ": ", "'646rpx'", ",\r\n              ", "left", ": ", "'236rpx'", ",\r\n              ", "width", ": ", "'278rpx'", ",\r\n              ", "height", ": ", "'278rpx'", "\r\n            }\r\n          }\r\n        ]\r\n      }\r\n\r\n    \r\n      ", "let", " { ", "path", ": __path } = mpvue.getStorageSync(", "'createImagePath'", ")\r\n      mpvue.saveImageToPhotosAlbum({\r\n        ", "filePath", ": __path,\r\n        success(res) {\r\n          ", "// mpvue.showToast({", "\r\n          ", "//   title: '保存成功',", "\r\n          ", "//   icon: 'success',", "\r\n          ", "//   duration: 800,", "\r\n          ", "//   mask: true", "\r\n          ", "// });", "\r\n      \r\n        },\r\n        fail(res) {\r\n          ", "// mpvue.showToast({", "\r\n          ", "//   title: '保存失败',", "\r\n          ", "//   icon: 'fail',", "\r\n          ", "//   duration: 800,", "\r\n          ", "//   mask: true", "\r\n          ", "// });", "\r\n        }\r\n      });\r\n    },\r\n\t\r\n", "复制代码", "这里涉及到画二维码， 如果你的二维码图片不是一个线上的链接的话，这时需要做一些小操作。", "\r\n", "我的项目中二维码的图片传过来是一个流，所以用img的src默认发送get请求，就能拿到这个图片了。\r\n所以url会直接发送get请求拿到图片。", "\r\n", "canvas的层级", "\r\n", "canvas的层级是最高的，底部的分享块会被遮住，这时你需要用两套方案，一个是纯展示用的，用正常的html来写，给用户看这个名片。\r\n下载或分享的时候再y用canvas生产你想要图片，接着调用微信的保存api，将图片下载或分享。", "\r\n", "let", " { ", "path", ": __path } = mpvue.getStorageSync(", "'createImagePath'", ")\r\nmpvue.saveImageToPhotosAlbum({\r\n  ", "filePath", ": __path,\r\n  success(res) {\r\n    ", "// mpvue.showToast({", "\r\n    ", "//   title: '保存成功',", "\r\n    ", "//   icon: 'success',", "\r\n    ", "//   duration: 800,", "\r\n    ", "//   mask: true", "\r\n    ", "// });", "\r\n\r\n  },\r\n  fail(res) {\r\n    ", "// mpvue.showToast({", "\r\n    ", "//   title: '保存失败',", "\r\n    ", "//   icon: 'fail',", "\r\n    ", "//   duration: 800,", "\r\n    ", "//   mask: true", "\r\n    ", "// });", "\r\n  }\r\n});\r\n", "复制代码", "此时就能顺利完成保存名片的功能了。", " "]}
{"title": "微信小程序数据字段大小写问题 ", "author": "Rolan", "pub_time": "2019-7-17 00:46", "content": [" \n                     \n                    ", "这两天在开发微信", "小程序", "登录以及加解密的时候，因为数据大小写的问题被坑了一把。", "场景", "小程序调用\t", "wx.login", " 时会获得\t", "code", " ，传输给服务端可以得到\t", "openid", " ,\t", "unionid(绑定了开放平台)", " ,\t", "session_key", "小程序调用\t", "getUserInfo", " 会获得\t", "encrypted_data", " ,\t", "iv", " ,解密后得到\t", "unionId", " ,\t", "openId", "unionid", " 和\t", "openid", " 这两个场景\t", "键名大小写是不同的", "例子", "服务端根据\t", "code获取session_key", " 返回结果如下：", "{\r\n    ", "\"session_key\"", ": ", "\"我是session_key\"", ",\r\n    ", "\"openid\"", ": ", "\"我是openid\"", ",\r\n    ", "\"unionid\"", ": ", "\"我是unionid\"", "\r\n}\r\n", "服务端根据\t", "session_key解密encrypted_data和iv", " 返回结果如下：", "{\r\n    ", "\"openId\"", ": ", "\"OPENID\"", ",\r\n    ", "\"nickName\"", ": ", "\"NICKNAME\"", ",\r\n    ", "\"gender\"", ": GENDER,\r\n    ", "\"city\"", ": ", "\"CITY\"", ",\r\n    ", "\"province\"", ": ", "\"PROVINCE\"", ",\r\n    ", "\"country\"", ": ", "\"COUNTRY\"", ",\r\n    ", "\"avatarUrl\"", ": ", "\"AVATARURL\"", ",\r\n    ", "\"unionId\"", ": ", "\"UNIONID\"", ",\r\n    ", "\"watermark\"", ":\r\n    {\r\n        ", "\"appid\"", ":", "\"APPID\"", ",\r\n        ", "\"timestamp\"", ":TIMESTAMP\r\n    }\r\n}\r\n", "可以看到两次同样的字段\t", "openid", " 和\t", "unionid", " 大小写是不同的，此处容易踩坑。", "结论", "服务端根据\t", "code换session_key/openid/unionid", " 是\t", "小写", "服务端根据\t", "encrypted_data和iv", " 解密得到的\t", "openId/unionId", " 是\t", "大写", "最后，祝大家在开发过程中少踩坑。", " "]}
{"title": "publish一个微信小程序的日历组件 ", "author": "Rolan", "pub_time": "2019-7-17 00:52", "content": [" \n                     \n                    ", "公司下一个", "小程序", "项目会用到日历组件，所以准备自己先写一个。由于小程序支持了npm，可以开发和使用第三方自定义组件包，索性就尝试下发布一个日历组件。在设计稿没出来前，样式就先这样了（有没有一丝熟悉感）", "使用", "地址", "1.安装", "npm ", "install", " ", "--save miniprogram-simple-calendar", "\r\n复制代码", "2.在需要使用 calendar 的页面 page.json 中添加 calendar 自定义组件配置", "{\r\n  ", "\"usingComponents\"", ": {\r\n    ", "\"simple-calendar\"", ": ", "\"miniprogram-simple-calendar\"", "\r\n  }\r\n}\r\n复制代码", "在wxml中使用", "<", "simple-calendar", " ", "bindselect", "=", "\"select\"", ">", "</", "simple-calendar", ">", "\r\n复制代码", "注意：使用npm前，先在根目录 ", "npm init", " ，然后执行安装命令，再点击开发者工具中的菜单栏：工具 --> 构建 npm ，再勾选“使用 npm 模块”选项，具体查看文档。", "开发小程序组件", "怎么开发并发布一个小程序插件，官方文档在这里：开发第三方自定义组件", "根据介绍下载官方的项目模板，结构如下：", "|--miniprogram_dev ", "//", " 开发环境构建目录\r\n|--miniprogram_dist ", "//", " 生产环境构建目录\r\n|--src ", "//", " 源码\r\n|   |--components ", "//", " 通用自定义组件\r\n|   |--images ", "//", " 图片资源\r\n|   |\r\n|   |--xxx.js", "/xxx.wxml/", "xxx.json", "/xxx.wxss /", "/ 暴露的 js 模块/", "自定义组件入口文件\r\n|\r\n|--test ", "//", " 测试用例\r\n|--tools ", "//", " 构建相关代码\r\n|   |--demo ", "//", " demo 小程序目录，开发环境下会被拷贝生成到 miniprogram_dev 目录中\r\n|   |--config.js ", "//", " 构建相关配置文件\r\n|\r\n|--gulpfile.js\r\n复制代码", "miniprogram_dev： ", "npm run dev", " 或 ", "npm run watch", " 都会生成小程序代码到此目录，在开发者工具中打开此目录就可以预览", "miniprogram_dist： ", "npm run build", " 打包出的文件", "src：源码目录，我们需在此开发组件，源代码会被构建并生成到 miniprogram_dev/components 目录下", "使用less", "项目支持配置 less 开发，但是需要改几处地方：", "tools/config.js", " 中", "wxss", ": {\r\n  ", "less", ": true, ", "// 使用 less 来编写 wxss", "\r\n  ", "// ...", "\r\n}\r\n复制代码", "tools/checkcomponents.js", " 中", "componentListMap", ".wxssFileList", ".push", "(", "`${fileBase}.less`", ") ", "// 后缀改为less", "\r\n复制代码", "tools/build.js", " 中", "/**\r\n  * 监听 wxss 变化\r\n  */", "\r\n gulp.task(", "`", "${id}", "-watch-wxss`", ", () => {\r\n   ", "this", ".cachedComponentListMap.wxssFileList = ", "null", "\r\n   ", "return", " gulp.watch(\r\n     ", "'**/*.less'", ",   ", "// 将这里改为.less", "\r\n     {", "cwd", ": srcPath, ", "base", ": srcPath},\r\n     gulp.series(", "`", "${id}", "-component-wxss`", ")\r\n   )\r\n })\r\n复制代码", "获取每月天数", "关于开发日历的原理，随便一搜都能看到很多，我就不多说了，不过有一点我想提一下，那就是每个月天数的获取。不少教程都是把月份的天数存为一个数组，然后根据闰平年计算二月的天数，这样也很容易实现，而我用的是另外一个方法，也有不少教程说到，那就是获取每个月的最后一天是几号，最后一天是几号那这个月就多少天了。", "在JavaScript中，要获取指定日期，比如获取 ", "2019-02-01", " 的日期，我们可以这样：", "new", " ", "Date", "(", "2019", ",", "1", ",", "1", ")\r\n复制代码", "正式因为我明确知道要获取几月几号的日期，所以才可以这么写，那如果要获取最后一天的日期呢？其实可以这么写：", "new", " ", "Date", "(", "2019", ",", "2", ",", "0", ") ", "// 获取2月的最后一天日期", "\r\n复制代码", "初看觉得很奇怪，很容易以为是获取 2 月的的第一天，但这里需要注意的是，月份是从 0 开始的，所以这里的 2 表示的是 3 月，而 0 其实就表示往 1 号前退一天，那就是 2 月的最后一天了，再使用 ", "getDate()", " 就可以拿到本月天数了", " "]}
{"title": "你知道如何在小程序中推送模板消息？ ", "author": "Rolan", "pub_time": "2019-7-17 00:56", "content": [" \n                     \n                    ", "前段时间剁手了 PS4,在浏览商店时，发现官方商店真的不好用，主要是网络原因，次要是页面设计。所以就想自己做一个游戏查询的", "小程序", "，可以关注某个游戏，然后在这个游戏打折的时候发送通知给用户。最后发现有个很大的问题是：小程序没法直接给用户推送消息（当时还不知道模板消息），服务号才能。然后就用邮箱实现了通知功能，但是邮箱的局限实在是太大了（各大免费邮箱每天的发件数都很小，自己搭建的邮件服务器虽然没有发件限制，但是大概率会被放到垃圾箱）。", "\r\n", "然后某天在微信小程序的管理后台发现了模板消息这个东西，查了会资料发现可以通过这个来实现消息推送。要给用户发送模板消息需要", "formId/prepay_id", "这样一个东西，这个东西是怎么来的呢？", "\r\n\r\n", "\r\n", "formId:这个可以通过表单的提交来获取，需要在", "组件中设置属性", "report-submit=\"true\"", ",这样每次对这个表单的提交一次就会产生一个 formId.", "\r\n", "prepay_id:这个是支付动作产生的，具体的我也不太清楚，毕竟个人小程序并不能支付.", "\r\n", "\r\n", "下面具体来讲讲前后台的实现，前台使用 mpvue，后台使用 java", "\r\n", "前台获取 formId", "\r\n", "既然可以通过 form 的 submit 操作来获取到 formId,那我们稍微拓展一下，将我们的小程序页面中所有用户能点击的部分都用 form,button 来包裹一下，这样用户感知不到有表单提交操作，我们也能获取大量的 formId。", "\r\n", "注意不能用叠加的方式来一次点击获取多个 formId,这样方法已经不行了，获取到的都会是一样的。", "\r\n", "获取一个模板", "\r\n", "要发送模板消息，首先要在小程序的管理后台上添加模板，步骤如下：", "\r\n", "1.在模板库中选择一个模板", "\r\n", "2.选择显示参数", "\r\n", "选择要显示在消息中的参数，这里选择如下两个参数：", "\r\n", "这样就有了一个模板可以用来发消息了，在我的模板中可以看到模板 id，和字段 id", "\r\n", "获取 formId", "\r\n", "formId 是通过表单提交来获取到了，为了获取足够多的 formId,可以将能够点击的组件（比如按钮，列表单元..）包裹在 form 中，这样用户在日常使用中就能够收集到足够多的 formId。下面以包裹一个有赞的按钮为例。因为小程序的限制，设置", "form-type", "属性的按钮必须为 form 组件的直接子节点，所以并不能够在 form 中使用自定义组件，并将", "form-type='submit'", "设置到自定义组件中。", "\r\n", "template 部分如下：", "\r\n", "<!-- 要获取formId，需要给form设置report-submit=\"true\"的属性，然后在form-type=\"submit\"的按钮上产生点击动作，才会触发表单提交的事件--formSubmit,进而获取到formId -->", "\r\n", "<", "form", " @", "submit", "=", "\"formSubmit\"", " ", "report-submit", "=", "\"true\"", " ", "class", "=", "\"bottom\"", ">", "\r\n  ", "<", "button", " ", "style", "=", "\"border:0;display:inline-block\"", " ", "plain", "=", "\"true\"", " ", "form-type", "=", "\"submit\"", " @", "click", "=", "\"back\"", ">", "\r\n    ", "<", "van-button", " ", "round", " ", "type", "=", "\"primary\"", " ", "size", "=", "\"small\"", " @", "click", "=", "\"back\"", ">", "返回", "</", "van-button", ">", "\r\n  ", "</", "button", ">", "\r\n  ", "<", "button", " ", "style", "=", "\"border:0;display:inline-block\"", " ", "plain", "=", "\"true\"", " ", "form-type", "=", "\"submit\"", " @", "click", "=", "\"watchGame\"", ">", "\r\n    ", "<", "van-button", " ", "round", " ", "type", "=", "\"danger\"", " ", "size", "=", "\"small\"", ">", "{{watchText}}", "</", "van-button", ">", "\r\n  ", "</", "button", ">", "\r\n  ", "<", "button", " ", "style", "=", "\"border:0;display:inline-block\"", " ", "plain", "=", "\"true\"", " ", "form-type", "=", "\"submit\"", " ", "open-type", "=", "\"share\"", ">", "\r\n    ", "<", "van-button", " ", "round", " ", "type", "=", "\"info\"", " ", "size", "=", "\"small\"", ">", "分享", "</", "van-button", ">", "\r\n  ", "</", "button", ">", "\r\n", "</", "form", ">", "\r\n", "复制代码", "style 目的为了去除原生 button 的背景，边框啥的，把 button 当一个 div 来使用，然后在 button 中设置 form-type 和 click 属性,这样既不影响 formId 的属性，也对原有逻辑不产生任何影响。之所以将 click 放在 button 上是因为 button 内部的组件没法获取到点击事件。", "\r\n", "formSubmit 代码如下：", "\r\n", "formSubmit(e) {\r\n  ", "let", " item = {\r\n    ", "value", ": e.mp.detail.formId,\r\n    ", "expireTime", ": ", "Date", ".now() + ", "7", " * ", "24", " * ", "60", " * ", "60", " * ", "1000", "\r\n  };\r\n  ", "this", ".globalData.formIdList.push(item);\r\n},\r\n", "复制代码", "该函数是在表单提交时触发，用于获取 formId,将 formId 和这个 formId 的过期时间一起存到 globalData 全局数据中。然后找一个时机将这些 formId 发送给服务器保存起来就行了。", "\r\n", "这里放上我的做法以供参考。", "\r\n", "我是在每次发送 http 请求前检查是不是有 formId 需要发送到服务器，如果有就将这些数据 JSON 序列化后放到一个自定义 header 中，发送出去，具体代码如下(http 请求工具为：flyio)：", "\r\n", "var", " Fly = ", "require", "(", "\"flyio/dist/npm/wx\"", ");\r\n", "var", " fly = ", "new", " Fly();\r\n", "//在请求预处理中", "\r\nfly.interceptors.request.use(", "request", " =>", " {\r\n  request.headers[", "\"jwt-token\"", "] = wxUtil.getGlobalData(", "\"jwt-token\"", ");\r\n  ", "//如果有formId就放到header里送过去", "\r\n  ", "let", " formIdList = getApp().globalData.formIdList;\r\n  ", "if", " (formIdList.length > ", "0", ") {\r\n    request.headers[", "\"formIdList\"", "] = ", "JSON", ".stringify(formIdList);\r\n    getApp().globalData.formIdList = [];\r\n  }\r\n  ", "if", " (request.method == ", "\"GET\"", ") {\r\n    request.params[", "\"_t\"", "] = ", "new", " ", "Date", "().getTime();\r\n  }\r\n  ", "return", " request;\r\n});\r\n", "复制代码", "下面将后台的实现，基于 Spring Boot.", "\r\n", "后台处理", "\r\n", "搜集 formId", "\r\n", "首先需要把 formId 收集起来存到数据库，那么就需要检查每个请求，看 header 中有没有携带 formId,如果有就存到数据库中，注意要和用户对应起来，某个用户点击产生的 formId 只能用于给这个用户推送消息。", "\r\n", "因为要将 formId 和用户绑定起来，因此我是在身份认证过滤器中进行的 formId 处理，身份认证成功后，处理 formId。代码如下：", "\r\n", "/**\r\n * Description: 从请求头中获取formIdList,并插入数据库\r\n *\r\n * ", "@param", " request 请求头\r\n * ", "@return", " void\r\n * ", "@author", " fanxb\r\n * ", "@date", " 2019/5/6 16:39\r\n */", "\r\n", "private", " ", "void", " ", "checkFormId", "(HttpServletRequest request)", " ", "{\r\n    String str = request.getHeader(Constant.HEADER_FORM_ID);\r\n    ", "if", " (StringUtil.isEmpty(str)) {\r\n        ", "return", ";\r\n    }\r\n    List<FormKey> formKeyList = JSON.parseArray(str, FormKey.class);\r\n    ", "//UserContextHolder用户将当前线程和用户绑定起来，方便后面获取用户信息", "\r\n    ", "int", " userId = UserContextHolder.get().getUser().getUserId();\r\n    formKeyList.forEach(item -> item.setUserId(userId));\r\n    ", "this", ".formKeyDao.insertMany(formKeyList);\r\n}\r\n", "复制代码", "发送微信提醒", "\r\n", "通过官方文档可以知道发送消息的流程如下：", "\r\n", "1 获取 accessToken,调用微信的大多数接口都需要这个东西，这个通过 appId 和 secret 来获取。详情参见：", "developers.weixin.qq.com/miniprogram…", "\r\n", "2 调用微信发送服务通知的接口.这个接口文档在:", "点击跳转", "\r\n", "最终发送的 http 请求是这样的：", "\r\n", "url: https:", "//api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=上面获取的accessToken", "\r\nmethod: post\r\n\r\n请求体格式为：application/json; charset=utf", "-8", "\r\n\r\nbody:{\r\n  ", "\"touser\"", ": ", "\"用户的openId\"", ",\r\n  ", "\"template_id\"", ": ", "\"模板id\"", ",\r\n  ", "\"page\"", ": ", "\"点击跳转的小程序url路径\"", ",\r\n  ", "\"form_id\"", ": ", "\"收集到的formId\"", ",\r\n  ", "\"data\"", ": {\r\n    ", "\"keyword1\"", ": {\r\n      ", "\"value\"", ": ", "\"您有一个信息的提示消息\"", "\r\n    },\r\n    ", "\"keyword2\"", ": {\r\n      ", "\"value\"", ": ", "\"这是消息内容\"", "\r\n    }\r\n  },\r\n  ", "\"emphasis_keyword\"", ": ", "\"keyword1.DATA\"", "\r\n}\r\n", "复制代码", "data 中的数据的按照顺序 keyword1,keyword2 对应于模板中字段的顺序。", "\r\n", "结束", "\r\n", "工程全部源码在这里：", "github", " "]}
{"title": "微信小程序之楼层效果 ", "author": "Rolan", "pub_time": "2019-7-18 00:29", "content": [" \n                     \n                    ", " ", "今天做了一个", "小程序", "实现一个楼层效果  带大家分享下经验和api的使用吧", " 如图 将左边和右边各分了一个组件  目录如下", " ", "　　　其中list页面是这个楼层效果的页面  ", "　　　components是组成这个页面的两个组件", "　　　list为列表组件   title为右边字母固定的组件", "list主页面的代码如下", "　　", "<!--", "pages/list/list.wxml", "-->", "\r\n", "<", "view ", "class", "='container'", ">", "\r\n  ", "<", "view ", "class", "='box'", ">", "\r\n    ", "<", "view ", "class", "='left' ", "wx:if", "=\"{{contentList.length}}\"", ">", "\r\n      ", "<", "list ", "contentList", "=\"{{contentList}}\"", " class", "=\"listComponent\"", " currentKey", "=\"{{currentKey}}\"", " bind:ChangeId", "=\"changeId\"", "></", "list", ">", "\r\n    ", "</", "view", ">", "\r\n  ", "</", "view", ">", "\r\n  ", "<", "view ", "class", "='right'", ">", "\r\n    ", "<", "title ", "wx:for", "=\"{{titleList}}\"", " wx:key", "=\"{{index}}\"", " title", "=\"{{item}}\"", " class", "=\"{{titleIndex===index?'titleActive':''}}\"", " index", "=\"{{index}}\"", " bind:ChangeId", "=\"changeId\"", " bind:Changekey", "='changekey'", "></", "title", ">", "\r\n  ", "</", "view", ">", "\r\n", "</", "view", ">", "上述代码用到的api 有如下几点", "1、组件的调用  需要我们在下list.json先配置下  然后直接当成标签使用", " ", "2、组件的传值  如上述代码  ", "contentList=\"{{contentList}}\"", "  这种写法就是组件间的传值", "在list组件的接收这个参数的写法", "　　", "properties: {", "　　　　contentList: Array,", "　　　　currentKey: String", "　　},", "接收后使用的话直接当做data的参数使用就可以喽", " ", " ", "3、父组件向子组件传个函数  让子组件调用然后改变父组件某个参数", "bind:ChangeId=\"changeId\" ", "   这样是传发   bind是必须的 用来区分是函数还是变量  bind后面的是让子组件调用使用的", "引号里面为父组件真正定义的函数   注意这里直接  引号 不要加{{}}  ", "子组件接受这个函数并且调用", "　　", "　　", "this.triggerEvent('ChangeId', {", "　　　　id: index", "　　})", " ", " 4、自己定义的函数然后写在哪里  ", "父组件的话直接找个地方写函数名就行了", " ", "但是子组件需要写在methods里面", " ", " 5、加入我们定义的函数需要传参数怎么办", "第二行就是传参  通过data-传一个叫做id的参数    这里提一下  循坏的时候如果我们不去指定变量的话会是item代表每一项 index代表下标     如果指定的话可以   wx:", "for-index=", "\"i\"  指定下标    ", "wx:", "for-item=", "\"myItem\" 制定每一项", " ", "然后接受都在e里面 如下   ", "e.currentTarget.dataset", " ", "6、wx:if=\"{{contentList.length}}\"  判断是否要渲染下面的元素条件  注意这里的条件要放在括号里面去", "这个条件需要注意下 因为第一次没加这个东西出现了bug", " 7、class名的添加     class=\"{{titleIndex===index?'titleActive':''}}\"     基本类似Vue   但是这里加括号", " ", "以上为主页面的知识点介绍  下面介绍的list页面的知识点    title页面没有什么可说的  基本上就是点击事件控制父组件的", "变量得到颜色的切换  以及右边连带滚动", " ", " ", "list组件代码", "<", "scroll-view\r\n  ", "scroll-y \r\n  scroll-into-view", "=\"{{currentKey}}\"", " \r\n  scroll-with-animation \r\n  bindscroll", "=\"handleScroll\"", "\r\n  class", "='scroll'\r\n", ">", "\r\n  ", "<", "view ", "wx:for", "=\"{{contentList}}\"", " wx:key", "=\"{{index}}\"", " id", "=\"{{item.key}}\"", " class", "='content'", ">", "\r\n    ", "<", "text ", "class", "='title'", ">", "{{item.key}}", "</", "text", ">", "\r\n\r\n    ", "<", "view ", "class", "='item' ", "wx:for", "=\"{{item.row}}\"", " wx:key", "=\"{{index}}\"", ">", "\r\n      ", "<", "image ", "src", "='{{item.img}}' ", "class", "='img'", "></", "image", ">", "\r\n      ", "<", "text ", "class", "='item-text'", ">", "{{item.name}}", "</", "text", ">", "\r\n    ", "</", "view", ">", "\r\n  ", "</", "view", ">", "\r\n", "</", "scroll-view", ">", " ", "1、首先  我们这个页面需要做一个滚动列表  然后调用了下人家封装好的 scroll-view这个组件  ", "对于这个组件简单的介绍下", "a、首先 想要得到滚动效果 并且触发组件封装的函数必须让其高度小于内容的高度", "在上述代码中也就是 scroll这个元素小于  content这个元素", "不然触发不了", "b、scroll-y   设置滚动方向", "　 scroll-into-view=\"{{currentKey}}\"   这个变量绑顶右边字母的 id   在点击id的时候就会直接让右边对应的内容滚到顶部   ", "　先给这个currtKey默认右边第一个元素的id  之后点击的时候动态改变", "     scroll-with-animation   添加动画效果", "　bindscroll=\"handleScroll\"    在页面滚动的时候会触发这个  然后打印事件对象e会得到你想要的", "在这里我们需要e.detail.scrollTop;  获取滚到高度就可以喽", "c、 然后此时这个题到这里基本上就完成了一大半了   剩下的就是我们获取 ABC所有元素距离顶部的距离  然后将这些数字储存起来然后这个函数中循坏比较改变右边class的类名就可以了   ", "此时碰见的bug就是在子组件如何获取到某一个class类名的所有元素距离顶部高度", " ", " ", "通过官网api查看    下面这个方法就可以获取到", "this.createSelectorQuery().selectAll(\".content\").boundingClientRect((rect) => {", " ", "rect.forEach(item => {", "arr.push(item.top)", "}).exec((res) => {", "})", " ", "注意在子组件中是this.createSelectorQuery()   在父组件中是ws.createSelectorQuery()", " ", "此时我们在子组件的生命周期  ready第一次获取没有获取到 就是因为上面的那个判断条件没有写", " ", "我们的数据是通过请求传过来的  第一次向这个子组件传了个空数组 页面什么也没有渲染  而这个周期执行了一遍", "所以导致我们什么都没有获取到  找了半天才发现   简直到了怀疑人生的地步 唉~~~", " ", " ", " ", "下面顺带介绍下生命周期吧", " ", "页面生命周期", "小程序注册完成后，加载页面，触发onLoad方法。", "页面载入后触发onShow方法，显示页面。", "首次显示页面，会触发onReady方法，渲染页面元素和样式，一个页面只会调用一次。", "当小程序后台运行或跳转到其他页面时，触发onHide方法。", "当小程序有后台进入到前台运行或重新进入页面时，触发onShow方法。", "当使用重定向方法wx.redirectTo(OBJECT)或关闭当前页返回上一页wx.navigateBack()，触发onUnload", " ", "组件的生命周期", "created 组件实例化，但节点树还未导入，因此这时不能用setData", "attached 节点树完成，可以用setData渲染节点，但无法操作节点", "ready 组件布局完成，这时可以获取节点信息，也可以操作节点", "moved 组件实例被移动到树的另一个位置", "detached 组件实例从节点树中移除", " ", " ", "组件生命周期不带on  页面的带on", " ", "最后介绍下下面地步的配置", "通过全局配置 tabBar", "在app.json配置如下", " \"tabBar\"", ": {\r\n    ", "\"color\": \"#333333\",  ", "//", "字体颜色", "\r\n    \"selectedColor\": \"#f00\",  ", "//", "选中颜色", "\r\n    \"backgroundColor\": \"#ffffff\",  ", "//", "底部导航颜色", "\r\n    \"borderStyle\": \"black\", ", "//", "边框色", "\r\n    \"position\": \"bottom\",   ", "//", "设置是在底部还是顶部", "\r\n    \"list\"", ": [\r\n      {\r\n        ", "\"text\": \"首页\",  ", "//", "文字内容", "\r\n        \"selectedIconPath\": \"./static/index-active.png\",  ", "//", "选中的时候图片展示", "\r\n        \"iconPath\": \"./static/index.png\",  ", "//", "平常状态下的图片样式", "\r\n        \"pagePath\": \"pages/index/index\"   ", "//", "点击要跳转的位置", "\r\n", "      },\r\n      {\r\n        ", "\"text\": \"通讯录\"", ",\r\n        ", "\"selectedIconPath\": \"./static/find-active.png\"", ",\r\n        ", "\"iconPath\": \"./static/find.png\"", ",\r\n        ", "\"pagePath\": \"pages/list/list\"", "\r\n      },\r\n      {\r\n        ", "\"text\": \"购物车\"", ",\r\n        ", "\"selectedIconPath\": \"./static/cart-active.png\"", ",\r\n        ", "\"iconPath\": \"./static/cart.png\"", ",\r\n        ", "\"pagePath\": \"pages/cart/cart\"", "\r\n      },\r\n      {\r\n        ", "\"text\": \"我的\"", ",\r\n        ", "\"selectedIconPath\": \"./static/me-active.png\"", ",\r\n        ", "\"iconPath\": \"./static/me.png\"", ",\r\n        ", "\"pagePath\": \"pages/my/my\"", "\r\n      }\r\n    ]\r\n  },", " ", " ", " ", " ", " 本文GitHup的地址   ", "https://github.com/qiang-chen/weixin-project", " "]}
{"title": "小程序分页实践：编写可复用分页组件 ", "author": "Rolan", "pub_time": "2019-7-18 00:44", "content": [" \n                     \n                    ", "项目中遇到 tab切换列表，每个tab都需要分页的需求，分页流程具有相似性，于是想将分页封装为组件，方便应用。", "\r\n", "组件的应用已写成一个小demo，效果如下图所示（数据用mock模拟）：", "\r\n", "源码可以查看：", "wxapp-pagination", "\r\n", "\r\n", "项目需求", "\r\n", "具体项目需求：", "\r\n", "\r\n", "查看自己相关的会议（页面命名为 meetings）", "\r\n", "tab切换，分为：\r\n", "\r\n", "“我的会议”（我参加的会议，后面会以 \"join\" 为 key区分）", "\r\n", "“我的预约”（我预约的会议，后面会以 \"book\" 为 key区分）", "\r\n", "\r\n", "\r\n", "一次加载10条（size=10），拉到底部后，加载下一页（page = page +1）", "\r\n", "\r\n", "当然，作为前端，要考虑", "性能方面的需求", "：", "\r\n", "\r\n", "首次只加载默认tab页的首页，其他tab等到点击到对应tab才开始加载。", "\r\n", "回到已加载过的tab页，保留原数据不重新加载。", "\r\n", "\r\n", "所以原型图大概就长这样：", "\r\n", "\r\n", "逻辑实现", "\r\n", "与分页逻辑相关的项目结构如下：", "\r\n", "├── components\r\n│\t\t├── meeting-item\t  ", "# 列表item", "\r\n│\t\t└── pagination\t          ", "# 分页组件", "\r\n├── model\r\n│   └── user.js\t\t\t\t  ", "# 我的相关 model", "\r\n└── pages\r\n│\t   └── user\t                  ", "# 我的相关页面", "\r\n│       ├── meetings\t\t          ", "# 我的会议（就是tab要分页的页面啦）", "\r\n│       └── ...\r\n│\r\n└── vant-weapp\r\n", "复制代码", "还是用图理一下他们之间的关系吧：", "\r\n", "在组件内监听触发分页事件", "\r\n", "触发分页的事件是滚动到页面的底部，", "小程序", "中，触发该事件是Page页面的", "onReachBottom", "事件，但是这个事件只能在Page中触发，所以要将这个触发时机传递给pagination组件。", "\r\n", "解决思路是：组件 pagination 内，设置", "key", "属性，每当", "onReachBottom", "事件触发之后，设置组件属性 ", "key", "  为一个随机字符串，当组件 pagination 监听到", "key", "的变化的时候，做出分页操作。", "\r\n", "// components/pagination/index.js", "\r\nComponent({\r\n  ", "properties", ": {\r\n    ", "key", ": {\r\n      ", "type", ": ", "String", ",\r\n      ", "observer", ": ", "'_loadMoreData'", "  ", "// _loadMoreData 为分页操作", "\r\n    }\r\n  }\r\n})\r\n", "复制代码", "<!-- pages/user/meetings/index.wxml -->", "\r\n", "<", "tabs", " ", "active", "=", "\"{{currentTab}}\"", " ", "bind:change", "=", "\"onChange\"", ">", "\r\n    ", "<", "tab", " ", "title", "=", "\"我的会议\"", " ", "data-key", "=", "\"{{type['JOIN']}}\"", ">", "\r\n      ", "<", "view", " ", "class", "=", "\"meeting-list\"", ">", "\r\n          ", "<", "pagination", " \r\n            ", "name", "=", "\"JOIN\"", "\r\n            ", "key", "=", "\"{{joinKey}}\"", " \r\n          >", "\r\n          ", "</", "pagination", ">", "\r\n      ", "</", "view", ">", "\r\n    ", "</", "tab", ">", "\r\n\r\n    ", "<", "tab", " ", "title", "=", "\"我的预约\"", ">", "\r\n      ", "<", "view", " ", "class", "=", "\"meeting-list\"", ">", "\r\n        ", "<", "pagination", " \r\n          ", "name", "=", "\"BOOK\"", "\r\n          ", "key", "=", "\"{{bookKey}}\"", "\r\n        >", "\r\n        ", "</", "pagination", ">", "\r\n      ", "</", "view", ">", "\r\n    ", "</", "tab", ">", "\r\n", "</", "tabs", ">", "\r\n", "复制代码", "Page({\r\n  onReachBottom(){\r\n    ", "const", " key = scene[+", "this", ".data.currentTab].key ", "// 对应tab对应key", "\r\n    ", "this", ".setData({\r\n      [key]: random(", "16", ")\r\n    })\r\n  }\r\n})\r\n", "复制代码", "\r\n", "分页组件的实现逻辑", "\r\n", "触发到达底部之后，需要加载数据。但再加载之前，先满足加载的条件：", "\r\n", "\r\n", "上一页还未加载完成（loading = true），不重复加载", "\r\n", "当前页面全部加载完（ended = true），不继续加载", "\r\n", "\r\n", "具体加载流程为：", "\r\n", "\r\n", "**page：**触发 onReachBottom 事件，修改 pagination组件 ", "key", " 值", "\r\n", "component：", " ", "key", "值监听到变化，触发加载事件", "_loadMoreData", "\r\n", "component：", "_loadMoreData", "中判断满足条件后，触发加载列表函数 ", "this.triggerEvent('getList')", "，并传入页面参数page 和 size。", "\r\n", "**page：**向model层获取数据。", "\r\n", "**page：**获取数据后，传递给 pagination组件", "list", "和", "total", " 值。", "\r\n", "component：", "list", " 监听到变化，判断是否加载完成。", "\r\n", "\r\n", "\r\n", "component", "\r\n", "// components/pagination/index.js", "\r\nComponent({\r\n  ", "properties", ": {\r\n    ", "name", ": ", "String", ",\r\n    ", "key", ": {\r\n      ", "type", ": ", "String", ",\r\n      ", "observer", ": ", "'_loadMoreData'", "  ", "// _loadMoreData 为分页操作", "\r\n    },\r\n    ", "size", ": {  ", "// 每次加载条目数", "\r\n      type: ", "Number", ",\r\n      ", "value", ": ", "10", "\r\n    },\r\n    ", "total", ": ", "Number", ", ", "// 页面总数", "\r\n    list: {\t\t\t\t ", "// 已加载条目", "\r\n      type: ", "Array", ",\r\n      ", "observer", ": ", "'_endState'", "     ", "// 每次加载完新数据，判断数据是否全部加载完成", "\r\n    }\r\n  },\r\n\r\n  ", "data", ": {\r\n    ", "page", ": ", "0", ",\t\t\t\t", "// 当前第几页", "\r\n    loading: ", "false", ", ", "// 是否正在加载", "\r\n    ended: ", "false", "    ", "// 数据是否已全部加载完成", "\r\n  },\r\n  \r\n  ", "methods", ": {\r\n    _loadMoreData(){\r\n      ", "const", " { loading, ended, size } = ", "this", ".data\r\n      ", "if", " (loading) ", "return", "  ", "// 上一页还未加载完成，不加载", "\r\n      ", "if", " (ended) ", "return", "    ", "// 当前页面全部加载完，不加载", "\r\n      ", "const", " page = ", "this", ".data.page + ", "1", "\r\n\r\n      ", "this", ".setData({\r\n        ", "loading", ": ", "true", ",  ", "// 开始加载新页面loading设置为true", "\r\n        page\r\n      })\r\n      ", "// 触发加载下一页，并传入参数", "\r\n      ", "this", ".triggerEvent(", "'getList'", ", {\r\n        page,\r\n        size\r\n      })\r\n    },\r\n    _endState(val, oldVal) {\r\n      ", "const", " { total, list } = ", "this", ".properties\r\n      ", "let", " ended = ", "false", "\r\n      ", "// 判断数据是否全部加载完成", "\r\n      ", "if", " (list.length >= total) {\r\n        ended = ", "true", "\r\n      }\r\n      ", "this", ".setData({\r\n        ", "loading", ": ", "false", ", ", "// 当前页面加载完成，loading设置为false", "\r\n        ended\r\n      })\r\n    }\r\n  }\r\n})\r\n", "复制代码", "\r\n", "page", "\r\n", "<!-- pages/user/meetings/index.wxml -->", "\r\n", "<", "pagination", " \r\n  ", "name", "=", "\"BOOK\"", "\r\n  ", "key", "=", "\"{{bookKey}}\"", "\r\n  ", "bind:getList", "=", "\"getBookMeetings\"", "\r\n  ", "list", "=", "\"{{bookMeetings}}\"", "\r\n  ", "total", "=", "\"{{bookTotal}}\"", "\r\n>", "\r\n", "</", "pagination", ">", "\r\n", "复制代码", "\r\n", "循环列表item", "\r\n", "pagination组件获取了可循环的列表，初始想法是循环slot，但是在slot中却获取不到 item 对象：", "\r\n", "<", "view", " ", "wx:for", "=", "\"{{list}}\"", " ", "wx:for-item", "=", "\"item\"", " ", "wx:key", "=", "\"index\"", ">", "\r\n  ", "<", "slot", ">", "</", "slot", ">", "\r\n", "</", "view", ">", "\r\n", "复制代码", "解决的办法是将每个列表项封装为组件，循环", "抽象节点", "，这样对其他页面的分页具有可拓展性。", "\r\n", "componentGenerics", " 字段中声明：", "\r\n", "// components/pagination/index.json\r\n{\r\n  \"componentGenerics\": {\r\n    \"selectable\": true\r\n  },\r\n  // ...\r\n}\r\n", "复制代码", "使用抽象节点：", "\r\n", "<!-- components/pagination/index.wxml -->", "\r\n", "<", "view", " ", "wx:for", "=", "\"{{list}}\"", " ", "wx:for-item", "=", "\"item\"", " ", "wx:key", "=", "\"index\"", ">", "\r\n    ", "<", "selectable", " ", "item", "=", "\"{{item}}\"", ">", "</", "selectable", ">", "\r\n", "</", "view", ">", "\r\n", "复制代码", "指定“selectable”具体是哪个组件：", "\r\n", "<!-- pages/user/meetings/index.wxml -->", "\r\n", "<", "pagination", " \r\n  ", "generic:selectable", "=", "\"meeting-item\"", "\r\n\t// ", "...", " 其他属性\r\n>", "\r\n", "</", "pagination", ">", "\r\n", "复制代码", "对应 json 文件定义对应 ", "usingComponents", " ：", "\r\n", "// pages/user/meetings/index.json\r\n{\r\n  \"usingComponents\": {\r\n    \"pagination\":\"/components/pagination/index\",\r\n    \"meeting-item\":\"/components/meeting-item/index\"\r\n  }\r\n}\r\n", "复制代码", "meeting-item 组件接收一个属性 item，这样在 meeting-item 组件中，就可以获取到循环列表的item值，并正常绘制页面。", "\r\n", "\r\n", "实现切换懒加载", "\r\n", "给pagination添加", "initImmediately", "属性，当", "initImmediately", "为true时，首次加载页面，并用变量 ", "initState", "标记是否已经初始化页面过。", "\r\n", "// components/pagination/index.js", "\r\nComponent({\r\n  ", "properties", ": {\r\n    ", "initImmediately", ": {\r\n      ", "type", ": ", "Boolean", ",\r\n      ", "value", ": ", "true", ",\r\n      ", "observer", ": ", "function", "(", "val", ")", "{\r\n        ", "if", " (val && !", "this", ".data.initState) {\r\n          ", "this", ".initData()\r\n        }\r\n      }\r\n    },\r\n    ", "// ...", "\r\n  },\r\n  ", "data", ": {\r\n     ", "initState", ": ", "false", ", ", "// 是否已经加载过", "\r\n     ", "// ...", "\r\n  },\r\n  ", "lifetimes", ": {\r\n    ", "attached", ": ", "function", " (", ") ", "{\r\n      ", "if", " (", "this", ".data.initImmediately){\r\n        ", "this", ".initData()\r\n      }\r\n    },\r\n  },\r\n  ", "methods", ": {\r\n    initData(){\r\n      ", "console", ".info(", "`", "${", "this", ".data.name}", ":start init data`", ")\r\n      ", "this", "._loadMoreData()\r\n      ", "this", ".setData({\r\n        ", "initState", ": ", "true", "\r\n      })   \r\n  \t},\r\n    ", "// ... ", "\r\n  \t_endState(val, oldVal) {\r\n      ", "if", " (!", "this", ".data.initState) ", "return", " \r\n      ", "// ...", "\r\n  \t},\r\n  }\r\n})\r\n", "复制代码", "当currentTab为当前类型的时候，", "initImmediately", " 设置为 true。", "\r\n", "<!-- pages/user/meetings/index.wxml -->", "\r\n", "<", "pagination", " \r\n    ", "name", "=", "\"JOIN\"", "\r\n    ", "init-immediately", "=", "\"{{currentTab==type['JOIN']}}\"", "\r\n    // ", "...", "\r\n>", "\r\n", "</", "pagination", ">", "\r\n\r\n", "<", "pagination", " \r\n    ", "name", "=", "\"BOOK\"", "\r\n    ", "init-immediately", "=", "\"{{currentTab==type['BOOK']}}\"", "\r\n    // ", "...", "\r\n>", "\r\n", "</", "pagination", ">", "\r\n", "复制代码", "\r\n", "组件的复用", "\r\n", "完成了以上组件，在对其他分页的页面，可以直接复用。比如，实现一个获取全部用户列表的分页，只需要新增一个user-item的组件，像这样调用：", "\r\n", "<", "pagination", " \r\n  ", "name", "=", "\"USER\"", "\r\n  ", "key", "=", "\"{{key}}\"", " \r\n  ", "bind:getList", "=", "\"getUserList\"", " \r\n  ", "list", "=", "\"{{userList}}\"", " \r\n  ", "total", "=", "\"{{userTotal}}\"", "\r\n  ", "generic:selectable", "=", "\"user-item\"", "\r\n>", "\r\n", "</", "pagination", ">", "\r\n", "复制代码", "具体应用可以查看我写的小demo：", "wxapp-pagination", "。", " "]}
{"title": "小程序分享海报的坑 ", "author": "Rolan", "pub_time": "2019-7-18 00:50", "content": [" \n                     \n                    ", "UI小哥给了一张UI图，让我实现", "小程序", "的分享海报", "\r\n", "\r\n", "\r\n", "踩坑如下：", "\r\n", "\r\n", "canvas绘制文字自动换行", "\r\n", "canvas绘制文字，首行缩进", "\r\n", "canvas剪切圆形头像", "\r\n", "\r\n", "一、canvas 绘制文字，自动换行", "\r\n", "因为canvas.fillText绘制文字是没用自动换行的功能的，所以需要自己封装个函数来实现。", "\r\n", "canvas有个API", "ctx.measureText(string str).width", "可以获取字符串的像素长度", "\r\n", "当一行文字的像素长度超过画布的长度时，就可以另起一行重新绘制文字", "\r\n", "/*\r\n\tlineWidth:一行文字的总长度\r\n\tstr:是要写入的字符串\r\n\tinitX:初始时，文字距离画布边缘的距离\r\n\tcanvasWidth:画布的宽度\r\n\tlineHeight:是行高\r\n*/", "\r\n", "let", " lineWidth = ", "0", ";\r\n", "for", "(", "let", " i=", "0", ";i<str.length;i++){\r\n    lineWidth += ctx.measureText(str[i]).width;", "//每次增加一个字符的像素长度", "\r\n    ", "if", "(lineWidth>canvasWidth", "-2", "*initX){\r\n        ", "//减去两个initX是想在文字两边都有相同距离的空白", "\r\n        ctx,fillText(str.substr(", "0", ",i),initX,initY);\r\n        initY+=lineHeight;\r\n        str = str.str.substr(i);\r\n        i = -i;\r\n        lineWidth;\r\n\t}\r\n    ", "//如果绘制到字符串的末尾了，还没超过画布的宽度", "\r\n    ", "if", "(i==str.length", "-1", "){\r\n        ctx.fillText(str.substr(", "0", ",i+", "1", "),initX,initY);\r\n    }\r\n}\r\n", "复制代码", "二、canvas首行缩进", "\r\n", "因为canvas没有首行缩进的属性，只能是，绘制的时候，向右偏移两个字符的长度", "\r\n", "/*\r\n\tindent:布尔值，是否缩进\r\n\tindentWidth:缩进的像素宽度\r\n*/", "\r\n", "let", " indent = ", "true", ";\r\n", "let", " indentWidth = ", "0", ";\r\n", "for", "(", "let", " i=", "0", ";i<str.length;i++){\r\n    lineWidth += ctx.measureText(str[i]).width;\r\n    ", "if", "(indent && i==", "1", "){\r\n        indentWidth = lineWidth;\r\n    }\r\n    ", "if", "(indent && lineWidth>canvasWidth", "-2", "*initX-indentWidth){\r\n        ctx.fillText(str.substr(", "0", ",i),initX+indentWidth,initY);\r\n        initY+=lineHeight;\r\n        lineWidth=", "0", ";\r\n        indent = ", "false", ";\r\n        str = str.substr(i);\r\n        i =", "-1", ";\r\n    }\r\n}\r\n", "复制代码", "小总结，将自动换行和首行缩进，封装成函数如下", "\r\n", "/*\r\n\tctx：wx.createCanvasContext获取的画布上下文\r\n\tinitX:距离画布左边缘的距离\r\n\tinitY:距离画布上部的距离\r\n\tstr:要绘制的字符串\r\n\tlineHeight:行高\r\n\tindent:布尔值，是否要首行缩进\r\n*/", "\r\ncanvasTextAutoLine(ctx,canvasWidth,str,initX,initY,lineHeight,indent=", "false", "){\r\n    ", "let", " lineWidth =  ", "0", ";\r\n    ", "let", " indentWidth=", "0", ";\r\n    ", "for", "(", "let", " i=", "0", ";i<str.length;i++){\r\n        lineWidth += ctx.measureText(str[i]).width;\r\n        ", "if", "(indent && i==", "1", "){\r\n            indentWidth = lineWidth;\r\n        }\r\n        ", "if", "(indent && lineWidth>canvasWidth", "-2", "*initX-indentWidth){\r\n            ctx.fillText(str.substr(", "0", ",i),initX+indentWidth,initY);\r\n            initY+=lineHeight;\r\n            lineWidth=", "0", ";\r\n            indent = ", "false", ";\r\n            str = str.substr(i);\r\n            i =", "-1", "; ", "//下次循环i会加1,所以下次循环就是1", "\r\n        }\r\n        ", "if", "(lineWidth>canvasWidth", "-2", "*initX){\r\n            ctx.fillText(str.substr(", "0", ",i),initX,initY);\r\n            initY+=lineHeight;\r\n            str=str.substr(i);\r\n            i=", "-1", ";\r\n            lineWidth=", "0", "; \r\n        }\r\n        ", "if", "(i==str.length", "-1", "){\r\n            ctx.fillText(str.substr(", "0", ",i+", "1", "),initX,initY);\r\n        }\r\n    }\r\n    ", "return", " initY;\r\n}\r\n", "复制代码", "三、canvas剪切出圆形的头像", "\r\n", "canvas的API", "ctx.clip()", "可以剪切图形，使用如下", "\r\n", "//1. 在使用clip()要先将之前绘制的图形保存", "\r\nctx.save();\r\n", "//2. 绘制你要剪切的图形", "\r\nctx.arc(", "25", ",", "25", ",", "25", ",", "0", ",", "Math", ".PI*", "2", ");\r\n", "//3. 剪切", "\r\nctx.clip();\r\n", "//4. 在剪切的范围内绘制图形，超过这个范围的不显示", "\r\nctx.drawImage(headImg,", "0", ",", "0", ",", "25", ",", "25", ");\r\n", "//5. 绘制完后，释放之前保存的图形", "\r\nctx.restore();\r\n", "复制代码", "结语", "\r\n", "作者：胡志武", "\r\n", "时间：2019/7/17", "\r\n", "本人大二，想找个前端实习生的工作。求职中。。。", " "]}
